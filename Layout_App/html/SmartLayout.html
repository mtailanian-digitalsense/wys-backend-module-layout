<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>SmartLayout API documentation</title>
<meta name="description" content="This module contain all logic for Layouts" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SmartLayout</code></h1>
</header>
<section id="section-intro">
<p>This module contain all logic for Layouts</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contain all logic for Layouts

&#34;&#34;&#34;

import random
import time
import math
import rtree
from deap import base
from deap import creator
from deap import tools
from deap import algorithms
from numpy import nan
from shapely import geometry, affinity
from shapely.geometry import Point, box, LineString, MultiLineString, MultiPolygon
from shapely.geometry.polygon import Polygon
from shapely.ops import unary_union, polygonize, linemerge, substring
import matplotlib.pyplot as plt

import viewer
import restrictions
from randrange import randrange
from get_areas2 import get_area2

# from Layout_App import viewer
# from Layout_App import restrictions
# from Layout_App.randrange import randrange
# from Layout_App.get_areas2 import get_area2

#from lines_areas_test import get_pol_zones
random.seed(100)

# Función que lee la planta en formato JSON, luego separa y entrega sus partes importantes
# Recibe como entrada un diccionario con información de la planta y los módulos en ella
def get_input(dictionary):
    &#34;&#34;&#34;Function that read the plant and the selected modules from a dictionary&#34;&#34;&#34;
    Planta = dictionary.get(&#39;selected_floor&#39;).get(&#39;polygons&#39;)
    Workspaces = dictionary.get(&#39;workspaces&#39;)
    plant = []
    for Area in Planta:
        plant.append(
            [Area.get(&#39;name&#39;), [(round(a.get(&#39;x&#39;) / 100, 1), round(a.get(&#39;y&#39;) / 100, 1)) for a in Area.get(&#39;points&#39;)]])

    outline = []
    holes = []
    areas = []
    for p in plant:
        if p[0] == &#39;WYS_AREA_UTIL&#39;:
            outline.append(p)
        elif p[0] == &#39;WYS_HOLE&#39;:
            holes.append(p)
        else:
            areas.append(p)

    input_list = []
    for ws in Workspaces:
        input_list.append([ws.get(&#39;name&#39;), ws.get(&#39;quantity&#39;), ws.get(&#39;width&#39;), ws.get(&#39;height&#39;),
                           ws.get(&#39;subcategory_id&#39;)])

    return outline, holes, areas, input_list


class Floor:
    def __init__(self, outline_points, holes_list):
        self.outline = outline_points
        self.holes = holes_list


class Module:
    def __init__(self, x, y, rotation, name, identificator, width_value, height_value, qty, fitval1, fitval2):
        self.x = x
        self.y = y
        self.rot = rotation
        self.name = name
        self.id = identificator
        self.width = width_value
        self.height = height_value
        self.qty = qty
        self.fitval1 = fitval1
        self.fitval2 = fitval2

    def show(self):
        print(self.name, self.x, self.y, self.rot, self.id, self.width, self.height, self.qty)

    def get_box(self):
        return box(self.x - self.width / 2, self.y - self.height / 2, self.x + self.width / 2, self.y + self.height / 2)


def select_zone(zones, zone, mod_cat, n):
    &#34;&#34;&#34;Function that selects a zone for each module&#34;&#34;&#34;
    z_names_qty = 0
    if mod_cat == 1:
        z_names = [k for k,v in zones.items() if &#39;ZONA SALAS REUNION FORMAL&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SALAS REUNION FORMAL &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SALAS REUNION FORMAL 0&#39;]
    elif mod_cat == 2:
        z_names = [k for k,v in zones.items() if &#39;ZONA PUESTOS DE TRABAJO&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA PUESTOS DE TRABAJO &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA PUESTOS DE TRABAJO 0&#39;]
    elif mod_cat == 3:
        z_names = [k for k,v in zones.items() if &#39;ZONA TRABAJO PRIVADO&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA TRABAJO PRIVADO &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA TRABAJO PRIVADO 0&#39;]
    elif mod_cat == 4:
        z_names = [k for k,v in zones.items() if &#39;ZONA SERVICIOS&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SERVICIOS &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SERVICIOS 0&#39;]
    elif mod_cat == 5:
        z_names = [k for k,v in zones.items() if &#39;ZONA SOPORTE&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SOPORTE &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SOPORTE 0&#39;]
    elif mod_cat == 6:
        z_names = [k for k,v in zones.items() if &#39;ZONA REUNIONES INFORMALES&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA REUNIONES INFORMALES &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA REUNIONES INFORMALES 0&#39;]
    elif mod_cat == 7:
        z_names = [k for k,v in zones.items() if &#39;ZONA ESPECIALES&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA ESPECIALES &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA ESPECIALES 0&#39;]

    return zone, z_names_qty


makeposcnt = 0
curr_bx = []
# Función que posiciona inicialmente los módulos en la planta
def makePos(planta, in_list, zones):
    &#34;&#34;&#34;Function that initially positions the modules in the plant&#34;&#34;&#34;
    make_time = time.time()
    global makeposcnt
    global curr_bx
    in_cnt = 0
    z = []

    mod = Module(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    for j in range(len(in_list)):
        for n in range(in_list[j][1]):
            if in_cnt == makeposcnt:
                mod.name = in_list[j][0]
                mod.qty = in_list[j][1]
                mod.width = round(in_list[j][2], 1)
                mod.height = round(in_list[j][3], 1)
                mod_cat = in_list[j][4]
            in_cnt+=1

    &#39;&#39;&#39;if mod_cat == 1:
        z = [z[0] for z in zones if &#39;ZONA SALAS REUNION FORMAL&#39; in z[1]]
    elif mod_cat == 2:
        z = [z[0] for z in zones if &#39;ZONA PUESTOS DE TRABAJO&#39; in z[1]]
    elif mod_cat == 3:
        z = [z[0] for z in zones if &#39;ZONA TRABAJO PRIVADO&#39; in z[1]]
    elif mod_cat == 4:
        z = [z[0] for z in zones if &#39;ZONA SERVICIOS&#39; in z[1]]
    elif mod_cat == 5:
        z = [z[0] for z in zones if &#39;ZONA SOPORTE&#39; in z[1]]
    elif mod_cat == 6:
        z = [z[0] for z in zones if &#39;ZONA REUNIONES INFORMALES&#39; in z[1]]
    elif mod_cat == 7:
        z = [z[0] for z in zones if &#39;ZONA ESPECIALES&#39; in z[1]]&#39;&#39;&#39;

    zone = None
    zone, zones_qty = select_zone(zones, zone, mod_cat, makeposcnt)
    
    if zone:
        minx, miny, maxx, maxy = zone.bounds
    else:
        minx, miny, maxx, maxy = planta.bounds
    
    #print(round(time.time() - start_time, 2), len(curr_bx), mod.name)
    #print(mod.name)
    rot = False
    larger_than_zone = False
    pos_retries = 0
    zones_idx = makeposcnt
    positional_time_limit = 0.005   # Recomendado 0.08        Tiempos iniciales de posicionamiento de módulos
    overlap_time_limit = 0.005      # Recomendado 0.05        Tiempos iniciales de posicionamiento de módulos
    while True:
        if time.time() - make_time &gt; 3*(positional_time_limit + overlap_time_limit) and not larger_than_zone:
            make_time = time.time()
            zones_idx += 1
            pos_retries += 1
            zone, zones_qty = select_zone(zones, zone, mod_cat, zones_idx)
            minx, miny, maxx, maxy = zone.bounds
        elif larger_than_zone:
            minx, miny, maxx, maxy = planta.bounds

        if rot:
            b = affinity.rotate(b, 90)
        else:
            p = Point(round(randrange(minx, maxx, 20), 1), round(randrange(miny, maxy, 20), 1))
            b = box(p.x - mod.width / 2, p.y - mod.height / 2, p.x + mod.width / 2, p.y + mod.height / 2)

        if pos_retries &lt; zones_qty and zone:
            condition1 = zone.contains(b) and planta.contains(b)
            if time.time() - make_time &gt;= positional_time_limit and not condition1:
                condition1 = zone.intersects(b) and planta.contains(b)
        elif not larger_than_zone:
            larger_than_zone = True
            #print(mod.name)
            condition1 = planta.contains(b)
        else:
            condition1 = planta.contains(b)
        
        if time.time() - make_time &gt;= overlap_time_limit and condition1:
            mod.x, mod.y = p.x, p.y
            curr_bx.append(b)
            makeposcnt += 1
            if makeposcnt &gt;= in_cnt:
                makeposcnt = 0
                curr_bx = []
            return mod

        condition2 = True

        if not curr_bx:
            condition2 = True
        else:
            for bx in curr_bx:
                if b.intersects(bx):
                    condition2 = False

        if condition1 and condition2:
            mod.x, mod.y = p.x, p.y
            curr_bx.append(b)
            makeposcnt += 1
            if makeposcnt &gt;= in_cnt:
                makeposcnt = 0
                curr_bx = []
            return mod
        rot = not rot

# Calcula la minima distancia de un módulo a una determinada área
def min_dist_to_area(lista):
    &#34;&#34;&#34;Function that calculates the minimum distance of a module to a certain area&#34;&#34;&#34;
    my_output = []
    i = 0
    curr_min = lista[0]
    if len(lista) == 1:
        my_output.append(curr_min)
        return (my_output)

    for j in range(i + 1, len(lista)):
        B = lista[j]
        # print(i, j, curr_min, B)
        if curr_min[0] == B[0]:
            if B[1] &lt;= curr_min[1]:
                curr_min = B
            if j + 1 == len(lista):
                my_output.append(curr_min)
                # print(&#39;append&#39;, curr_min)
        else:
            my_output.append(curr_min)
            # print(&#39;append&#39;, curr_min)
            curr_min = B
            if j + 1 == len(lista):
                my_output.append(curr_min)
        i = j
    return my_output


def smart_layout_async(dictionary, POP_SIZE=50, GENERATIONS=50):
    result = Smart_Layout(dictionary, POP_SIZE, GENERATIONS, IS_ASYNC=True)
    return result, dictionary

# Evalúa la factibilidad del polígono
def feasible_polygon(dims, polygon):
    &#34;&#34;&#34;Function that evaluates the feasibility of the polygon&#34;&#34;&#34;
    pol_centroid = polygon.centroid
    base_polygon = box(pol_centroid.x - dims[&#39;max_width&#39;] / 2, pol_centroid.y - dims[&#39;max_height&#39;] / 2, pol_centroid.x + dims[&#39;max_width&#39;] / 2, pol_centroid.y + dims[&#39;max_height&#39;] / 2)
    diff_polygon = base_polygon.difference(polygon)
    
    if diff_polygon.area &gt; 0.2*base_polygon.area:
        return False
    
    pol_minx, pol_miny, pol_maxx, pol_maxy = polygon.bounds
    pol_d1 = abs(pol_maxx-pol_minx)
    pol_d2 = abs(pol_maxy-pol_miny)
    pol_max_dim = max(pol_d1, pol_d2)
    pol_min_dim = min(pol_d1, pol_d2)

    base_d1 = dims[&#39;max_width&#39;]
    base_d2 = dims[&#39;max_height&#39;]
    base_max_dim = max(base_d1, base_d2)
    base_min_dim = min(base_d1, base_d2)

    &#39;&#39;&#39;print(&#34;pol_max_dim&#34;, pol_max_dim)
    print(&#34;pol_min_dim&#34;, pol_min_dim)
    print(&#34;base_max_dim&#34;, base_max_dim)
    print(&#34;base_min_dim&#34;, base_min_dim)
    print(&#34;-----&#34;)&#39;&#39;&#39;

    if pol_max_dim &gt;= base_max_dim and pol_min_dim &gt;= base_min_dim:
        return True
    return False

def assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, prev_sv_selected_zone, 
                        sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                        entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns the service zones&#34;&#34;&#34;
    if has_shaft:
        sv_candidate_idx = [k for k, v in shafts_adj_qty.items() if v &gt; min(shafts_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not sv_candidate_idx:
            sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not sv_candidate_idx:
                sv_candidate_idx = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not sv_candidate_idx:
                    sv_candidate_idx = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values())]
    else:
        sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not sv_candidate_idx:
            sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values())]
        sv_candidate_idx_filter = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and k in sv_candidate_idx]
        if sv_candidate_idx_filter:
            sv_candidate_idx = sv_candidate_idx_filter
    
    #print(&#34;Candidatos zona de servicios:&#34;, sv_candidate_idx)
    sv_candidate_zones = {}
    for c in sv_candidate_idx:
        sv_candidate_zones[c] = areas[c]
    sv_candidate_zones_areas = {k: v.area for k, v in sv_candidate_zones.items()}
    sv_candidate_idx = max(sv_candidate_zones_areas, key=sv_candidate_zones_areas.get)
    
    sv_selected_zone = areas[sv_candidate_idx]
    areas.pop(sv_candidate_idx, None)
    shafts_adj_qty.pop(sv_candidate_idx, None)
    crystal_adj_qty.pop(sv_candidate_idx, None)
    entrances_adj_qty.pop(sv_candidate_idx, None)
    core_adj_qty.pop(sv_candidate_idx, None)
    sv_banned_idx = []
    if prev_sv_selected_zone:
        prev_area = prev_sv_selected_zone.area
    else:
        prev_area = 0
    while sv_selected_zone.area + prev_area &lt; cat_area[4] + factor*cat_area[4] and len(areas) &gt; 0:
        sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zone.bounds, objects=True))))
        sv_nearest_idx = [k for k,v in areas.items() if v.bounds in sv_nearest and not k in sv_banned_idx]
        nearest_len = {idx: sv_selected_zone.intersection(areas[idx]).length for idx in sv_nearest_idx}
        if nearest_len:
            nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
            sv_candidate_zone = unary_union([sv_selected_zone, areas[nearest_candidate_idx]])
            if sv_candidate_zone.geom_type == &#39;Polygon&#39; and (sv_candidate_zone.area / sv_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                sv_selected_zone = sv_candidate_zone
                areas.pop(nearest_candidate_idx, None)
                shafts_adj_qty.pop(nearest_candidate_idx, None)
                crystal_adj_qty.pop(nearest_candidate_idx, None)
                entrances_adj_qty.pop(nearest_candidate_idx, None)
                core_adj_qty.pop(nearest_candidate_idx, None)
                sv_banned_idx = []
            else:
                sv_banned_idx.append(nearest_candidate_idx)
        else:
            break

    if not prev_sv_selected_zone:
        zones[&#39;ZONA SERVICIOS 0&#39;] = sv_selected_zone
        sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zone.bounds, objects=True))))
        sv_nearest_idx = [k for k,v in areas.items() if v.bounds in sv_nearest]
        for circ in circs_bounds:
            if sv_selected_zone.intersects(box(*circ)):
                circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sv_nearest_idx]
                sv_nearest_idx += circ_nearest_idx
    else:
        sv_selected_zones = [prev_sv_selected_zone, sv_selected_zone]
        sv_nearest_idx = []
        for i in range(len(sv_selected_zones)):
            zones[&#39;ZONA SERVICIOS &#39; + str(i)] = sv_selected_zones[i]
            sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zones[i].bounds, objects=True))))
            for k,v in areas.items():
                if v.bounds in sv_nearest and not k in sv_nearest_idx:
                    sv_nearest_idx.append(k)
            for circ in circs_bounds:
                if sv_selected_zone.intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sv_nearest_idx]
                    sv_nearest_idx += circ_nearest_idx
    
    return sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_pt_zones(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone,
                    sv_nearest_idx, pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns workstation zones&#34;&#34;&#34;
    pt_candidate_idx = []
    &#39;&#39;&#39;if sv_selected_zone:
        # Arreglo de indices de zonas cercanas al area de servicios
        if has_shaft:
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and (shafts_adj_qty[k] &gt; 0 or k in sv_nearest_idx)]
        else:
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and k in sv_nearest_idx]
    if not pt_candidate_idx:
        pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values())]&#39;&#39;&#39;
    pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    pt_candidate_zones = {}
    #print(&#34;Candidatos puestos de trabajo:&#34;, pt_candidate_idx)

    if len(pt_candidate_idx) &gt; 0:
        # Se asume que hay al menos 1 zona con muchas fachadas de cristal cercanas
        for c in pt_candidate_idx:
            pt_candidate_zones[c] = areas[c]
        if len(pt_candidate_zones) &lt; 2:
            # Si hay una zona con area maxima absoluta, se selecciona la primera zona siguiente que tenga area maxima
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and not k in pt_candidate_idx and feasible_polygon(cat_dims, areas[k])]
            pt_candidate_zones[pt_candidate_idx[0]] = areas[pt_candidate_idx[0]]
        # Se seleccionan solo 2 zonas de la lista de candidatas
        pt_selected_zones = []
        for i in range(2):
            pt_candidate_zones_areas = {k: v.area for k, v in pt_candidate_zones.items()}
            selected_zone_idx = max(pt_candidate_zones_areas, key=pt_candidate_zones_areas.get)
            selected_zone = pt_candidate_zones[selected_zone_idx]
            pt_selected_zones.append(selected_zone)
            #zones.append([selected_zone, &#39;ZONA PUESTOS DE TRABAJO&#39;])
            del pt_candidate_zones[selected_zone_idx]
            del pt_candidate_zones_areas[selected_zone_idx]
            areas.pop(selected_zone_idx, None)
            shafts_adj_qty.pop(selected_zone_idx, None)
            crystal_adj_qty.pop(selected_zone_idx, None)
            entrances_adj_qty.pop(selected_zone_idx, None)
            core_adj_qty.pop(selected_zone_idx, None)
        selector = False
        stuck_z0 = False
        stuck_z1 = False

        pt0_banned_idx = []
        pt1_banned_idx = []
        while pt_selected_zones[0].area + pt_selected_zones[1].area &lt; cat_area[2] + factor*cat_area[2] and len(areas) &gt; 0:
            if selector:
                pt_selected_zone = pt_selected_zones[1]
                pt_banned_idx = pt1_banned_idx
            else:
                pt_selected_zone = pt_selected_zones[0]
                pt_banned_idx = pt0_banned_idx
            pt_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(pt_selected_zone.bounds, objects=True))))
            pt_nearest_idx = [k for k,v in areas.items() if v.bounds in pt_nearest and not k in pt_banned_idx]
            pt_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in pt_nearest_idx]
            if pt_nearest_idx_filter:
                pt_nearest_idx = pt_nearest_idx_filter
            nearest_len = {idx: pt_selected_zone.intersection(areas[idx]).length for idx in pt_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                pt_candidate_zone = unary_union([pt_selected_zone, areas[nearest_candidate_idx]])
                if pt_candidate_zone.geom_type == &#39;Polygon&#39; and (pt_candidate_zone.area / pt_candidate_zone.minimum_rotated_rectangle.area) &gt; .80:
                    if selector:
                        pt_selected_zones[1] = pt_candidate_zone
                        pt1_banned_idx = []
                    else:
                        pt_selected_zones[0] = pt_candidate_zone
                        pt0_banned_idx = []
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                elif selector:
                    pt1_banned_idx.append(nearest_candidate_idx)
                else:
                    pt0_banned_idx.append(nearest_candidate_idx)

            elif stuck_z0 and stuck_z1:
                break
            elif selector:
                stuck_z1 = True
            else:
                stuck_z0 = True
            selector = not selector

        pt_nearest_idx = []
        for i in range(len(pt_selected_zones)):
            zones[&#39;ZONA PUESTOS DE TRABAJO &#39; + str(i)] = pt_selected_zones[i]
            pt_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(pt_selected_zones[i].bounds, objects=True))))
            for k,v in areas.items():
                if v.bounds in pt_nearest and not k in pt_nearest_idx:
                    pt_nearest_idx.append(k)
            for circ in circs_bounds:
                if pt_selected_zones[i].intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in pt_nearest_idx]
                    pt_nearest_idx += circ_nearest_idx

    return pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, prev_sp_selected_zone,
                        sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                        entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns support zones&#34;&#34;&#34;
    sp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0]
    sp_candidate_filter = [idx for idx in sp_candidate_idx if feasible_polygon(cat_dims, areas[idx])]
    entrances_idx = True
    if not sp_candidate_filter:
        sp_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; 0 ]
        sp_candidate_filter = [idx for idx in sp_candidate_idx if feasible_polygon(cat_dims, areas[idx])]
        entrances_idx = False

    sp_candidate_idx = sp_candidate_filter
    #print(&#34;Candidatos zona soporte:&#34;, sp_candidate_idx)
    if len(sp_candidate_idx) &gt; 0:
        # Se asume que hay al menos 1 zona candidata
        if len(sp_candidate_idx) &gt; 1:
            sp_candidate_zones = {}
            for c in sp_candidate_idx:
                sp_candidate_zones[c] = areas[c]

            if entrances_idx:
                sp_candidate_zones_areas = {}
                for e in entrances_bounds:
                    ent = box(*e)
                    entrances_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(e, objects=True))))
                    entrances_nearest_idx = [k for k,v in areas.items() if v.bounds in entrances_nearest]
                    for idx in entrances_nearest_idx:
                        inter_lenght = ent.intersection(areas[idx]).length
                        if idx in sp_candidate_zones_areas:
                            sp_candidate_zones_areas[idx] += inter_lenght
                        else:
                            sp_candidate_zones_areas[idx] = inter_lenght
                
                sp_selected_zone_idx = max(sp_candidate_zones_areas, key=sp_candidate_zones_areas.get)
            else:
                core = box(*core_bounds[0])
                core_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(core_bounds[0], objects=True))))
                core_nearest_idx = [k for k,v in areas.items() if v.bounds in core_nearest and k in sp_candidate_idx]
                sp_candidate_zones_areas = {idx: core.intersection(areas[idx]).length for idx in core_nearest_idx}
                sp_selected_zone_idx = max(sp_candidate_zones_areas, key=sp_candidate_zones_areas.get)

            sp_selected_zone = sp_candidate_zones[sp_selected_zone_idx]
        elif len(sp_candidate_idx) == 1:
            sp_selected_zone_idx = sp_candidate_idx[0]
            sp_selected_zone = areas[sp_selected_zone_idx]

        areas.pop(sp_selected_zone_idx, None)
        shafts_adj_qty.pop(sp_selected_zone_idx, None)
        crystal_adj_qty.pop(sp_selected_zone_idx, None)
        entrances_adj_qty.pop(sp_selected_zone_idx, None)
        core_adj_qty.pop(sp_selected_zone_idx, None)
        sp_banned_idx = []
        if prev_sp_selected_zone:
            prev_area = prev_sp_selected_zone.area
        else:
            prev_area = 0
        while sp_selected_zone.area + prev_area &lt; cat_area[5] + factor*cat_area[5] and len(areas) &gt; 0:
            sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zone.bounds, objects=True))))
            sp_nearest_idx = [k for k,v in areas.items() if v.bounds in sp_nearest and not k in sp_banned_idx]
            sp_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and k in sp_nearest_idx]
            if sp_nearest_idx_filter:
                sp_nearest_idx = sp_nearest_idx_filter
            nearest_len = {idx: sp_selected_zone.intersection(areas[idx]).length for idx in sp_nearest_idx}
            if nearest_len:
                sp_nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                sp_candidate_zone = unary_union([sp_selected_zone, areas[sp_nearest_candidate_idx]])
                if sp_candidate_zone.geom_type == &#39;Polygon&#39;  and (sp_candidate_zone.area / sp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    sp_selected_zone = sp_candidate_zone
                    areas.pop(sp_nearest_candidate_idx, None)
                    shafts_adj_qty.pop(sp_nearest_candidate_idx, None)
                    crystal_adj_qty.pop(sp_nearest_candidate_idx, None)
                    entrances_adj_qty.pop(sp_nearest_candidate_idx, None)
                    core_adj_qty.pop(sp_nearest_candidate_idx, None)
                    sp_banned_idx = []
                else:
                    sp_banned_idx.append(sp_nearest_candidate_idx)
            else:
                break
        
        if not prev_sp_selected_zone:
            zones[&#39;ZONA SOPORTE 0&#39;] = sp_selected_zone
            sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zone.bounds, objects=True))))
            sp_nearest_idx = [k for k,v in areas.items() if v.bounds in sp_nearest]
            for circ in circs_bounds:
                if sp_selected_zone.intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sp_nearest_idx]
                    sp_nearest_idx += circ_nearest_idx
        else:
            sp_selected_zones = [prev_sp_selected_zone, sp_selected_zone]
            sp_nearest_idx = []
            for i in range(len(sp_selected_zones)):
                zones[&#39;ZONA SOPORTE &#39; + str(i)] = sp_selected_zones[i]
                sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zones[i].bounds, objects=True))))
                for k,v in areas.items():
                    if v.bounds in sp_nearest and not k in sp_nearest_idx:
                        sp_nearest_idx.append(k)
                for circ in circs_bounds:
                    if sp_selected_zones[i].intersects(box(*circ)):
                        circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                        circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sp_nearest_idx]
                        sp_nearest_idx += circ_nearest_idx

    return sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_ptp_zone(circs_bounds, sv_selected_zone, sv_nearest_idx, sp_selected_zone, sp_nearest_idx, elements_idx, 
                    cat_area, factor, ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, 
                    crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns private work zones&#34;&#34;&#34;
    # Indices de areas cercanas a zona de soporte
    if sp_selected_zone and sv_selected_zone:
        # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and (not k in sp_nearest_idx and not k in sv_nearest_idx) and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            # En caso que NO se haya encontrado a lo menos un candidato que cumpla con el criterio, se relaja la restriccion
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and (not k in sp_nearest_idx or not k in sv_nearest_idx) and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
                if not ptp_candidate_idx:
                    ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    elif sp_selected_zone:
        # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    elif sv_selected_zone:
            # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and not k in sv_nearest_idx and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sv_nearest_idx and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    else:
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt;= min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    
    #print(&#34;Candidatos puestos de trabajo privado:&#34;)
    #print(ptp_candidate_idx)
    if len(ptp_candidate_idx) &gt; 0:
        # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el que tenga mas fachadas de cristal
        if len(ptp_candidate_idx) &gt; 1:
            ptp_candidate_zones = {}
            for c in ptp_candidate_idx:
                ptp_candidate_zones[c] = areas[c]
            ptp_candidate_zones_areas = {k: v.area for k, v in ptp_candidate_zones.items() if crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())}
            ptp_selected_zone_idx = max(ptp_candidate_zones_areas, key=ptp_candidate_zones_areas.get)
            ptp_selected_zone = ptp_candidate_zones[ptp_selected_zone_idx]
        elif len(ptp_candidate_idx) == 1:
            ptp_selected_zone_idx = ptp_candidate_idx[0]
            ptp_selected_zone = areas[ptp_selected_zone_idx]
        areas.pop(ptp_selected_zone_idx, None)
        shafts_adj_qty.pop(ptp_selected_zone_idx, None)
        crystal_adj_qty.pop(ptp_selected_zone_idx, None)
        entrances_adj_qty.pop(ptp_selected_zone_idx, None)
        core_adj_qty.pop(ptp_selected_zone_idx, None)
        ptp_banned_idx = []
        while ptp_selected_zone.area &lt; cat_area[3] + factor*cat_area[3] and len(areas) &gt; 0:
            ptp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(ptp_selected_zone.bounds, objects=True))))
            ptp_nearest_idx = [k for k,v in areas.items() if v.bounds in ptp_nearest and not k in ptp_banned_idx]
            ptp_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in ptp_nearest_idx]
            if ptp_nearest_idx_filter:
                ptp_nearest_idx = ptp_nearest_idx_filter
            nearest_len = {idx: ptp_selected_zone.intersection(areas[idx]).length for idx in ptp_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                ptp_candidate_zone = unary_union([ptp_selected_zone, areas[nearest_candidate_idx]])
                if ptp_candidate_zone.geom_type == &#39;Polygon&#39; and (ptp_candidate_zone.area / ptp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90 and feasible_polygon(cat_dims, ptp_candidate_zone.minimum_rotated_rectangle):
                    ptp_selected_zone = ptp_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    ptp_banned_idx = []
                else:
                    ptp_banned_idx.append(nearest_candidate_idx)
            else:
                break
        zones[&#39;ZONA TRABAJO PRIVADO 0&#39;] = ptp_selected_zone
        ptp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(ptp_selected_zone.bounds, objects=True))))
        ptp_nearest_idx = [k for k,v in areas.items() if v.bounds in ptp_nearest]
        for circ in circs_bounds:
            if ptp_selected_zone.intersects(box(*circ)):
                circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in ptp_nearest_idx]
                ptp_nearest_idx += circ_nearest_idx

    return ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                    elements_idx, cat_area, factor, prev_rf_selected_zone, rf_nearest_idx,
                    areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones):
    &#34;&#34;&#34;Function that maps the zones of formal meeting rooms&#34;&#34;&#34;
    nearest_len = None
    if ptp_selected_zone:
        # Se buscan indices de areas disponibles cercanas a la zona seleccionada como trabajo privado
        if sp_nearest_idx and sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx) and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx or not k in sv_nearest_idx) and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sp_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        else:
            rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        rf_candidate_len = {idx: ptp_selected_zone.intersection(areas[idx]).length for idx in rf_candidate_idx if ptp_selected_zone.intersection(areas[idx]).geom_type == &#39;LineString&#39; or ptp_selected_zone.intersection(areas[idx]).geom_type == &#39;MultiLineString&#39;}
    else:
        if sp_nearest_idx and sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx) and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())] 
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx)] 
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx or not k in sv_nearest_idx)]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sp_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        else:
            rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items()]
    
    #print(&#34;Candidatos reuniones formales:&#34;)
    #print(rf_candidate_idx)
    rf_candidate_zones = {}
    if len(rf_candidate_idx) &gt; 0:
        # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el de mayor area
        if len(rf_candidate_idx) &gt; 1:
            if rf_candidate_len:
                rf_selected_zone_idx = max(rf_candidate_len, key=rf_candidate_len.get)
                rf_selected_zone = areas[rf_selected_zone_idx]
            else:
                for c in rf_candidate_idx:
                    rf_candidate_zones[c] = areas[c]
                rf_candidate_zones_areas = {k: v.area for k, v in rf_candidate_zones.items()}
                rf_selected_zone_idx = max(rf_candidate_zones_areas, key=rf_candidate_zones_areas.get)
                rf_selected_zone = rf_candidate_zones[rf_selected_zone_idx]
        elif len(rf_candidate_idx) == 1:
            rf_selected_zone_idx = rf_candidate_idx[0]
            rf_selected_zone = areas[rf_selected_zone_idx]

        areas.pop(rf_selected_zone_idx, None)
        shafts_adj_qty.pop(rf_selected_zone_idx, None)
        crystal_adj_qty.pop(rf_selected_zone_idx, None)
        entrances_adj_qty.pop(rf_selected_zone_idx, None)
        core_adj_qty.pop(rf_selected_zone_idx, None)
        rf_banned_idx = []
        if prev_rf_selected_zone:
            prev_area = prev_rf_selected_zone.area
        else:
            prev_area = 0
        while rf_selected_zone.area + prev_area &lt; cat_area[1] + factor*cat_area[1]:
            rf_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(rf_selected_zone.bounds, objects=True))))
            rf_nearest_idx = [k for k,v in areas.items() if v.bounds in rf_nearest and not k in rf_banned_idx]
            rf_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in rf_nearest_idx]
            if rf_nearest_idx_filter:
                rf_nearest_idx = rf_nearest_idx_filter
            nearest_len = {idx: rf_selected_zone.intersection(areas[idx]).length for idx in rf_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                rf_candidate_zone = unary_union([rf_selected_zone, areas[nearest_candidate_idx]])
                if rf_candidate_zone.geom_type == &#39;Polygon&#39; and (rf_candidate_zone.area / rf_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    rf_selected_zone = rf_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    rf_banned_idx = []
                else:
                    rf_banned_idx.append(nearest_candidate_idx)
            else:
                break

        if not prev_rf_selected_zone:
            zones[&#39;ZONA SALAS REUNION FORMAL 0&#39;] = rf_selected_zone
            rf_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(rf_selected_zone.bounds, objects=True))))
            rf_nearest_idx = [k for k,v in areas.items() if v.bounds in rf_nearest]
        else:
            rf_selected_zones = [prev_rf_selected_zone, rf_selected_zone]
            for i in range(len(rf_selected_zones)):
                zones[&#39;ZONA SALAS REUNION FORMAL &#39; + str(i)] = rf_selected_zones[i]
    
    return rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_esp_zone(sp_nearest_idx, elements_idx, cat_area, factor, esp_selected_zone, 
                    esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns the zones of special zones&#34;&#34;&#34;
    if sp_nearest_idx:
        esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not esp_candidate_idx:
            esp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0 and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not esp_candidate_idx:
                esp_candidate_idx = [k for k, v in core_adj_qty.items() if v == max(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not esp_candidate_idx:
                    esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                    if not esp_candidate_idx:
                        esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx]
                        if not esp_candidate_idx:
                            esp_candidate_idx = [k for k,v in areas.items()]
    else:
        esp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0 and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not esp_candidate_idx:
            esp_candidate_idx = [k for k, v in core_adj_qty.items() if v == max(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not esp_candidate_idx:
                esp_candidate_idx = [k for k,v in areas.items() if feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not esp_candidate_idx:
                    esp_candidate_idx = [k for k,v in areas.items()]

    #print(&#34;Candidatos especiales:&#34;, esp_candidate_idx)
    if len(esp_candidate_idx) &gt; 0:
        if len(esp_candidate_idx) &gt; 1:
            esp_candidate_zones = {}
            for c in esp_candidate_idx:
                esp_candidate_zones[c] = areas[c]
            esp_candidate_zones_areas = {k: v.area for k, v in esp_candidate_zones.items()}
            esp_selected_zone_idx = max(esp_candidate_zones_areas, key=esp_candidate_zones_areas.get)
            esp_selected_zone = esp_candidate_zones[esp_selected_zone_idx]
        elif len(esp_candidate_idx) == 1:
            esp_selected_zone_idx = esp_candidate_idx[0]
            esp_selected_zone = areas[esp_selected_zone_idx]
        
        areas.pop(esp_selected_zone_idx, None)
        shafts_adj_qty.pop(esp_selected_zone_idx, None)
        crystal_adj_qty.pop(esp_selected_zone_idx, None)
        entrances_adj_qty.pop(esp_selected_zone_idx, None)
        core_adj_qty.pop(esp_selected_zone_idx, None)
        esp_banned_idx = []
        while esp_selected_zone.area &lt; cat_area[7] + factor*cat_area[7] and len(areas) &gt; 0:
            esp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(esp_selected_zone.bounds, objects=True))))
            esp_nearest_idx = [k for k,v in areas.items() if v.bounds in esp_nearest and not k in esp_banned_idx]
            nearest_len = {idx: esp_selected_zone.intersection(areas[idx]).length for idx in esp_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                esp_candidate_zone = unary_union([esp_selected_zone, areas[nearest_candidate_idx]])
                if esp_selected_zone.geom_type == &#39;Polygon&#39; and (esp_candidate_zone.area / esp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    esp_selected_zone = esp_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    esp_banned_idx = []
                else:
                    esp_banned_idx.append(nearest_candidate_idx)
            else:
                break
        zones[&#39;ZONA ESPECIALES 0&#39;] = esp_selected_zone
        esp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(esp_selected_zone.bounds, objects=True))))
        esp_nearest_idx = [k for k,v in areas.items() if v.bounds in esp_nearest]
    
    return esp_selected_zone, esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones


def assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, prev_ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill):
    &#34;&#34;&#34;Function that assigns informal meeting areas&#34;&#34;&#34;
    if not prev_ri_selected_zone:
        # Se buscan como candidatos, indices de areas disponibles cercanas a la zonas seleccionadas como puestos de trabajo
        if pt_nearest_idx:
            ri_candidate_idx = [k for k,v in areas.items() if k in pt_nearest_idx]
            if not ri_candidate_idx:
                ri_candidate_idx = [k for k,v in areas.items()]
        else:
            ri_candidate_idx = [k for k,v in areas.items()]
        #print(&#34;Candidatos reuniones informales:&#34;, ri_candidate_idx)

        if len(ri_candidate_idx) &gt; 0:
            # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el de mayor area
            if len(ri_candidate_idx) &gt; 1:
                ri_candidate_zones = {}
                for c in ri_candidate_idx:
                    ri_candidate_zones[c] = areas[c]
                ri_candidate_zones_areas = {k: v.area for k, v in ri_candidate_zones.items()}
                ri_selected_zone_idx = max(ri_candidate_zones_areas, key=ri_candidate_zones_areas.get)
                ri_selected_zone = ri_candidate_zones[ri_selected_zone_idx]
            elif len(ri_candidate_idx) == 1:
                ri_selected_zone_idx = ri_candidate_idx[0]
                ri_selected_zone = areas[ri_selected_zone_idx]
            
            areas.pop(ri_selected_zone_idx, None)
            shafts_adj_qty.pop(ri_selected_zone_idx, None)
            crystal_adj_qty.pop(ri_selected_zone_idx, None)
            entrances_adj_qty.pop(ri_selected_zone_idx, None)
            core_adj_qty.pop(ri_selected_zone_idx, None)
            ri_banned_idx = []
            if ri_fill:
                expansion_condition = True
            else:
                expansion_condition = ri_selected_zone.area &lt; cat_area[6] + factor*cat_area[6]
            while expansion_condition and len(areas) &gt; 0:
                ri_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(ri_selected_zone.bounds, objects=True))))
                ri_nearest_idx = [k for k,v in areas.items() if v.bounds in ri_nearest and not k in ri_banned_idx]
                nearest_len = {idx: ri_selected_zone.intersection(areas[idx]).length for idx in ri_nearest_idx}
                if nearest_len:
                    nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                    ri_candidate_zone = unary_union([ri_selected_zone, areas[nearest_candidate_idx]])
                    if ri_candidate_zone.geom_type == &#39;Polygon&#39; and (ri_candidate_zone.area / ri_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                        ri_selected_zone = ri_candidate_zone
                        areas.pop(nearest_candidate_idx, None)
                        shafts_adj_qty.pop(nearest_candidate_idx, None)
                        crystal_adj_qty.pop(nearest_candidate_idx, None)
                        entrances_adj_qty.pop(nearest_candidate_idx, None)
                        core_adj_qty.pop(nearest_candidate_idx, None)
                        ri_banned_idx = []
                    else:
                        ri_banned_idx.append(nearest_candidate_idx)
                else:
                    break
            zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] = ri_selected_zone
            ri_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(ri_selected_zone.bounds, objects=True))))
            ri_nearest_idx = [k for k,v in areas.items() if v.bounds in ri_nearest]
            return ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones
    else:
        ri_zones_list = [prev_ri_selected_zone]
        while len(areas) &gt; 0:
            ri_candidate_idx = [k for k,v in areas.items()]
            for idx in ri_candidate_idx:
                if len(areas) &lt; 1:
                    break
                ri_zones_list.append(areas[idx])
                areas.pop(idx, None)
                shafts_adj_qty.pop(idx, None)
                crystal_adj_qty.pop(idx, None)
                entrances_adj_qty.pop(idx, None)
                core_adj_qty.pop(idx, None)
        ri_zones = unary_union(ri_zones_list)
        if ri_zones.geom_type == &#39;Polygon&#39;:
            zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] = ri_zones
        else:
            ri_zones = list(ri_zones)
            for i in range(len(ri_zones)):
                zones[&#39;ZONA REUNIONES INFORMALES &#39;+ str(i)] = ri_zones[i]
        
        return prev_ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones
    
# Función que crea las zonas donde se ubicarán los módulos
def make_zones(planta, shafts, core, circs, entrances, crystal_facs, areas, cat_area, cat_dims):
    &#34;&#34;&#34;Function that creates the zones where the modules will be located&#34;&#34;&#34;
    zones = {}
    assigned_zones = {}
    p_minx, p_miny, p_maxx, p_maxy = planta.bounds
    c_minx, c_miny, c_maxx, c_maxy = core.bounds
    factor = 0.1
    
    #cat_area = {1:80 ,2:200, 3:70, 4:70, 5:30, 6: 50, 7:20}
    #cat_area = {2:200, 3:40, 4:70, 5:30, 6: 50, 7:20}
    #cat_area = {4:70}
    #cat_area = {1: 68.75, 2: 56.78450000000001, 3: 28.36, 4: 30.6116, 5: 16.790499999999998}
    #cat_area = {1: 80, 2: 160, 3: 58.36, 4: 30.6116, 5: 16.790499999999998, 6: 30, 7:30}
    #cat_area = {1: 36.349999999999994, 2: 56.78450000000001, 3: 38.16, 4: 30.6116, 5: 30, 6:20}
    #cat_area = {1: 36.349999999999994, 2: 113.56900000000002, 3: 28.36, 4: 30.6116, 5: 8.775}

    core_bounds = [core.bounds]
    entrances_bounds = list(map(lambda x: x.bounds, entrances))
    crystal_facs_bounds = list(map(lambda x: x.bounds, crystal_facs))
    circs_bounds = list(map(lambda x: Polygon(x).bounds, circs))
    #areas = {k: a.buffer(0.0001, cap_style=3, join_style=2) for k, a in areas.items()}
    areas_bounds = []
    for key, area in areas.items():
        areas_bounds.append(area.bounds)

    elements_idx = rtree.index.Index()

    crystal_adj_qty = {}
    entrances_adj_qty = {}
    shafts_adj_qty = {}
    core_adj_qty = {}

    if len(shafts) &gt; 0:
        has_shaft = True
    else:
        has_shaft = False

    if has_shaft:
        shafts_bounds = list(map(lambda x: x.bounds, shafts))
        elements = circs_bounds + core_bounds + shafts_bounds + entrances_bounds + crystal_facs_bounds + areas_bounds
        for i, e in enumerate(elements):
            elements_idx.insert(i, e)

        for key, area in areas.items():
            area_nearest = list(elements_idx.nearest(area.bounds, objects=True))
            crystal_adj = [obj for obj in area_nearest if tuple(obj.bbox) in crystal_facs_bounds]
            shafts_adj = [obj for obj in area_nearest if tuple(obj.bbox) in shafts_bounds]
            entrances_adj = [obj for obj in area_nearest if tuple(obj.bbox) in entrances_bounds]
            core_adj = [area.intersection(core).length for obj in area_nearest if tuple(obj.bbox) in core_bounds]
            crystal_adj_qty[key] = len(crystal_adj)
            shafts_adj_qty[key] = len(shafts_adj)
            entrances_adj_qty[key] = len(entrances_adj)
            core_adj_qty[key] = core_adj[0] if core_adj else 0
    else:
        elements = circs_bounds + core_bounds + entrances_bounds + crystal_facs_bounds + areas_bounds
        for i, e in enumerate(elements):
            elements_idx.insert(i, e)

        for key, area in areas.items():
            area_nearest = list(elements_idx.nearest(area.bounds, objects=True))
            crystal_adj = [obj for obj in area_nearest if tuple(obj.bbox) in crystal_facs_bounds]
            entrances_adj = [obj for obj in area_nearest if tuple(obj.bbox) in entrances_bounds]
            core_adj = [area.intersection(core).length for obj in area_nearest if tuple(obj.bbox) in core_bounds]
            crystal_adj_qty[key] = len(crystal_adj)
            entrances_adj_qty[key] = len(entrances_adj)
            core_adj_qty[key] = core_adj[0] if core_adj else 0
    #print(&#34;adyacentes a cristal:&#34;, crystal_adj_qty)
    #print(&#34;adyacentes al core:&#34;, core_adj_qty)
    # Zona de servicios
    # Se selecciona solo 1 area que tenga mas shafts o core cercanos
    sv_selected_zone = None
    sv_nearest_idx = None
    if 4 in cat_area and len(areas) &gt; 0:
        sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, 
                            crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims[4])
        assigned_zones[4] = sv_selected_zone
    
    # Zonas de puestos de trabajo
    pt_selected_zones = None
    pt_nearest_idx = None
    if 2 in cat_area and len(areas) &gt; 0:
        pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_pt_zones(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone,
                    sv_nearest_idx, pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[2])
        assigned_zones[2] = pt_selected_zones

    # Zona de soporte
    sp_selected_zone = None
    sp_nearest_idx = None
    if 5 in cat_area and len(areas) &gt; 0:
        sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, sp_selected_zone,
                    sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[5])
        assigned_zones[5] = sp_selected_zone

    # Zona de puestos de trabajo privado
    ptp_selected_zone = None
    ptp_nearest_idx = None
    if 3 in cat_area and len(areas) &gt; 0:
        ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ptp_zone(circs_bounds, sv_selected_zone, sv_nearest_idx, sp_selected_zone, sp_nearest_idx, elements_idx, cat_area, factor, ptp_selected_zone,
                    ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[3])
        assigned_zones[3] = ptp_selected_zone

    # Zona reuniones formales
    rf_selected_zone = None
    rf_nearest = None
    rf_nearest_idx = None
    if 1 in cat_area and len(areas) &gt; 0:
        rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                           elements_idx, cat_area, factor, rf_selected_zone, rf_nearest_idx,
                           areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones)
        assigned_zones[1] = rf_selected_zone
    
    esp_selected_zone = None
    esp_nearest = None
    esp_nearest_idx = None
    # Zona especiales
    if 7 in cat_area and len(areas) &gt; 0:
        esp_selected_zone, esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_esp_zone(sp_nearest_idx, elements_idx, cat_area, factor, esp_selected_zone, 
                    esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[7])
        assigned_zones[7] = esp_selected_zone

    ri_selected_zone = None
    ri_nearest_idx = None
    # Zona reuniones informales (o puestos de trabajo informal)
    if 6 in cat_area and len(areas) &gt; 0:
        ri_fill = False
        ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill)
        assigned_zones[6] = ri_selected_zone
    ri_fill = True

    if(len(areas) &gt; 0):
        diff_zones_areas = {}
        for k, zone in assigned_zones.items():
            if isinstance(zone, list):
                area_zone = 0
                for z in zone:
                    area_zone += z.area
                diff_area = area_zone - cat_area[k]
            else:
                diff_area = zone.area - cat_area[k]
            if diff_area &lt; 0:
                diff_zones_areas[k] = diff_area
        #print(diff_zones_areas)
        if diff_zones_areas:
            diff_zones_areas = {k: v for k, v in sorted(diff_zones_areas.items(), key=lambda item: item[1])}
            for k,v in diff_zones_areas.items():
                if k == 1:
                    rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                            assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                                        elements_idx, cat_area, factor, rf_selected_zone, rf_nearest_idx,
                                        areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones)
                    assigned_zones[k] = rf_selected_zone
                if k == 4:
                    sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                            assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, 
                            crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims[4])
                    assigned_zones[k] = sv_selected_zone
                if k == 5:
                    sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                        assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, sp_selected_zone,
                            sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                            entrances_adj_qty, core_adj_qty, zones, cat_dims[5])
                    assigned_zones[k] = sp_selected_zone

    last_areas_len = len(areas)
    while len(areas) &gt; 0:
        for zone_name, zone in zones.items():
            nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(zone.bounds, objects=True))))
            nearest_idx = [k for k,v in areas.items() if v.bounds in nearest]
            nearest_len = {idx: zone.intersection(areas[idx]).length for idx in nearest_idx if zone.intersection(areas[idx]).geom_type == &#39;LineString&#39; or zone.intersection(areas[idx]).geom_type == &#39;MultiLineString&#39;}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                candidate_zone = unary_union([zone, areas[nearest_candidate_idx]])
                if candidate_zone.geom_type == &#39;Polygon&#39;:
                    zones[zone_name] = candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
            elif len(areas) &lt; 1:
                break

        if last_areas_len == len(areas):
            break
        else:
            last_areas_len = len(areas)

    while len(areas) &gt; 0:
        ri_selected_zone = zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] if &#39;ZONA REUNIONES INFORMALES 0&#39; in zones.keys() else None
        ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill)
                    
    return zones

# Función que crea las circulaciones
def make_circ_ring(planta, core, shafts, entrances, voids, ring_width):
    &#34;&#34;&#34;Function that creates circulations&#34;&#34;&#34;
    p_minx, p_miny, p_maxx, p_maxy = planta.bounds
    c_minx, c_miny, c_maxx, c_maxy = core.bounds
    #e_minx, e_miny, e_maxx, e_maxy = entrances.bounds
    ring_distance_factor = 0.38

    planta_bbox_points = [Point(p_minx, p_miny), Point(p_maxx, p_maxy)]
    core_bbox_points = [Point(c_minx, c_miny), Point(c_maxx, c_maxy)]

    core_bbox_lines = []
    for p in core_bbox_points:
        line_v = LineString([(p.x, p_miny), (p.x, p_maxy)])
        line_h = LineString([(p_minx, p.y), (p_maxx, p.y)])

        core_bbox_lines.append(line_v)
        core_bbox_lines.append(line_h)
    
    planta_bbox_lines = []
    planta_h_bbox_lines = []
    planta_v_bbox_lines = []
    for p in planta_bbox_points:
        line_v = LineString([(p.x, p_miny), (p.x, p_maxy)])
        line_h = LineString([(p_minx, p.y), (p_maxx, p.y)])

        planta_bbox_lines.append(line_v)
        planta_bbox_lines.append(line_h)
        planta_h_bbox_lines.append(line_h)
        planta_v_bbox_lines.append(line_v)

    entrances_bbox_lines = []
    for e in entrances:
        e_minx, e_miny, e_maxx, e_maxy = e.bounds
        entrance_bbox_points = [Point(e_minx, e_miny), Point(e_maxx, e_maxy)]
        dist_minx_maxx = abs(e_maxx - e_minx)
        dist_miny_maxy = abs(e_maxy - e_miny)
        if(dist_minx_maxx &gt; dist_miny_maxy):
            for ep in entrance_bbox_points:
                e_line_v = LineString([(ep.x, p_miny), (ep.x, p_maxy)])
                entrances_bbox_lines.append(e_line_v)
        else:
            for ep in entrance_bbox_points:
                e_line_h = LineString([(p_minx, ep.y), (p_maxx, ep.y)])
                entrances_bbox_lines.append(e_line_h)

    ring_core_candidates = []
    for cb in core_bbox_lines:
        for eb in entrances_bbox_lines:
            if not cb.intersects(eb):
                ring_core_candidates.append(cb)

    if len(shafts) &gt; 0:
        for s in shafts:
            ring_core_candidates = [l for l in ring_core_candidates if not l.intersects(s)]
    if len(ring_core_candidates) &gt; 1:
        line_planta_dists = []
        for lr in ring_core_candidates:
            tmp_dist = []
            for pb in planta_bbox_lines:
                dist = lr.distance(pb)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            line_planta_dists.append(min(tmp_dist))
        #core_inter_len = [l.intersection(core).length for l in ring_core_candidates]
        #max_len_idx = core_inter_len.index(min(core_inter_len))
        min_len_idx = line_planta_dists.index(min(line_planta_dists))
        ring_core_candidates = [ring_core_candidates[min_len_idx]]
    
    
    ring_core_line = ring_core_candidates[0]

    rcl_x_points = []
    rcl_points = list(ring_core_line.coords)
    for p in rcl_points:
        rcl_x_points.append(p[0])
    rcl_diff_x = rcl_x_points[1] - rcl_x_points[0]
    
    if(rcl_diff_x == 0): #vertical
        if(rcl_points[0][0] &gt; core.centroid.x):
            rcl_width = Point(ring_width, 0)
        else:
            rcl_width = Point(-ring_width, 0)
    else: #horizontal
        if(rcl_points[0][1] &gt; core.centroid.y):
            rcl_width = Point(0, ring_width)
        else:
            rcl_width = Point(0, -ring_width)
    rcl_ring_points = []        
    for p in rcl_points:
        rcl_ring_points.append(Point(p[0]+rcl_width.x ,p[1]+rcl_width.y))
    
    rcl_ring_line = LineString(rcl_ring_points)

    ring_core_lines = [ring_core_line, rcl_ring_line]

    ring_lines = list(ring_core_lines)

    core_candidates_lines = [c for c in core_bbox_lines if not ring_core_line.equals(c)]

    #Primera linea espaciada desde el core
    line_planta_dists = []
    core_spaced_lines = []
    for cl in core_candidates_lines:
        cl_x_points =[]
        cl_points = list(cl.coords)
        for p in cl_points:
            cl_x_points.append(p[0])
        cl_diff_x = cl_x_points[1] - cl_x_points[0]
        if(cl_diff_x == 0): #vertical
            tmp_dist = []
            for pl in planta_v_bbox_lines:
                dist = cl.distance(pl)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            min_dist = min(tmp_dist)
            ring_distance = min_dist*ring_distance_factor
            if(cl_points[0][0] &gt; core.centroid.x):
                cl_width = Point(ring_distance, 0)
            else:
                cl_width = Point(-ring_distance, 0)
        else: #horizontal
            tmp_dist = []
            for pl in planta_h_bbox_lines:
                dist = cl.distance(pl)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            min_dist = min(tmp_dist)
            ring_distance = min_dist*ring_distance_factor
            if(cl_points[0][1] &gt; core.centroid.y):
                cl_width = Point(0, ring_distance)
            else:
                cl_width = Point(0, -ring_distance)
        cl_ring_points = []        
        for p in cl_points:
            cl_ring_points.append(Point(p[0]+cl_width.x ,p[1]+cl_width.y))
        core_spaced_lines.append(LineString(cl_ring_points))

    ring_lines += core_spaced_lines

    #Linea de grosor de lineas espaciadas realizadas anteriormente
    core_spaced_width_lines = []
    for cl in core_spaced_lines:
        cl_x_points =[]
        cl_points = list(cl.coords)
        for p in cl_points:
            cl_x_points.append(p[0])
        cl_diff_x = cl_x_points[1] - cl_x_points[0]
        if(cl_diff_x == 0): #vertical
            if(cl_points[0][0] &gt; core.centroid.x):
                cl_width = Point(ring_width, 0)
            else:
                cl_width = Point(-ring_width, 0)
        else: #horizontal
            if(cl_points[0][1] &gt; core.centroid.y):
                cl_width = Point(0, ring_width)
            else:
                cl_width = Point(0, -ring_width)
        cl_ring_points = []        
        for p in cl_points:
            cl_ring_points.append(Point(p[0]+cl_width.x ,p[1]+cl_width.y))
        core_spaced_width_lines.append(LineString(cl_ring_points))

    ring_lines += core_spaced_width_lines
    lu = unary_union(ring_lines + entrances_bbox_lines + [e.exterior for e in entrances] +  list(planta.interiors))
    pols = list(polygonize(planta.intersection(lu)))
    pols = [p for p in pols if p.area &lt; 50]

    entrances_bounds = list(map(lambda x: x.bounds, entrances))
    pols_bounds = list(map(lambda x: x.bounds, pols))

    holes_idx = rtree.index.Index()
    for i, e in enumerate(pols_bounds + entrances_bounds):
        holes_idx.insert(i, e)
    
    #Filtrado de areas que queden dentro del anillo
    for eb in entrances_bounds:
        entrances_circ = [tuple(obj.bbox) for obj in list(holes_idx.nearest(eb, objects=True)) if tuple(obj.bbox) in pols_bounds]
        if len(entrances_circ) &gt; 1:
            entrances_circ_areas = [box(*p).area for p in entrances_circ]
            entrances_circ = [p for p in entrances_circ if box(*p).area == min(entrances_circ_areas)]
        entrances_circ = entrances_circ[0]
        nearest_ec = [tuple(obj.bbox) for obj in list(holes_idx.nearest(entrances_circ, objects=True)) if tuple(obj.bbox) != entrances_circ]
        nearest_ec_areas = [box(*p).area for p in nearest_ec]
        for p in nearest_ec:
            if box(*p).area == max(nearest_ec_areas):
                pols_bounds.remove(p)

    circ_ring_pols = []
    void_pols = [Polygon(v) for v in voids]
    for pol in pols_bounds:
        box_pol = box(*pol)
        is_void = False
        for v in void_pols:
            if box_pol.equals(v):
                is_void = True
                break
        if not is_void:
            circ_ring_pols.append(box_pol)

    return circ_ring_pols

# Función que une áreas hasta lograr un área (en m2) mínima para cada área
def merge_min_areas(areas, max_dim):
    &#34;&#34;&#34;Function that joins areas to achieve a minimum area (in m2) for each area&#34;&#34;&#34;
    while not all([a.area &gt; max_dim for a in areas.values()]):
        areas_idx = rtree.index.Index()
        for i, e in enumerate([a.bounds for a in areas.values()]):
            areas_idx.insert(i, e)

        new_areas_list = []
        merged_idx = []
        
        for i, a in areas.items():
            if not i in merged_idx:
                if a.area &lt; max_dim:
                    nearest_idx = list(areas_idx.nearest(a.bounds))
                    nearest_len = {idx: a.intersection(areas[idx]).length for idx in nearest_idx if idx != i}
                    nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                    merged_idx.append(i)
                    merged_idx.append(nearest_candidate_idx)
                    new_area = unary_union([a, areas[nearest_candidate_idx]])
                    new_areas_list.append(new_area)

        leftover_areas = [v for k,v in areas.items() if not k in merged_idx]
        new_areas = {}
        for i, a in enumerate(leftover_areas + new_areas_list):
            new_areas[i] = a
        areas = new_areas

    while not all([all([a1.intersection(a2).area == 0 for a2 in areas.values() if a1 != a2]) for a1 in areas.values()]):
        areas_idx = rtree.index.Index()
        for i, e in enumerate([a.bounds for a in areas.values()]):
            areas_idx.insert(i, e)
        new_areas_list = []
        merged_idx = []

        for i, a in areas.items():
            if not i in merged_idx:
                nearest_idx = [idx for idx in list(areas_idx.nearest(a.bounds)) if idx != i and not idx in merged_idx]
                for idx in nearest_idx:
                    if a.intersection(areas[idx]).area &gt; 0:
                        merged_idx.append(i)
                        merged_idx.append(idx)
                        new_area = unary_union([a, areas[idx]])
                        new_areas_list.append(new_area)
                        break

        leftover_areas = [v for k,v in areas.items() if not k in merged_idx]
        new_areas = {}
        for i, a in enumerate(leftover_areas + new_areas_list):
            new_areas[i] = a
        areas = new_areas

    while not all([a.geom_type == &#39;Polygon&#39; for a in areas.values()]):
        k = 0
        i = 0
        while k + i != len(areas):
            v = areas[k]
            if v.geom_type == &#39;MultiPolygon&#39;:
                new_areas = list(v)
                areas[k] = new_areas.pop(0)
                for na in new_areas:
                    areas[len(areas)] = na
                    i += 1
            k += 1

    return areas


def merge_voids(voids, circ_pols):
    &#34;&#34;&#34;Function that joins circulations and holes in a list&#34;&#34;&#34;
    voids_pols = [Polygon(v) for v in voids]
    circ_voids_pols = list(unary_union(voids_pols + circ_pols))

    return [list(circ.exterior.coords) for circ in circ_voids_pols]

# Obtiene los módulos con las dimensiones máximas por categoría
def get_category_max_dims(inlist):
    &#34;&#34;&#34;Function that obtains the modules with the maximum dimensions by category&#34;&#34;&#34;
    cat_max_dims = {}
    for mod in inlist:
        cat_id = mod[4]
        cat_max_dims[cat_id] = {} if cat_id not in cat_max_dims else cat_max_dims[cat_id]
        cat_max_dims[cat_id][&#39;max_width&#39;] = mod[2] if &#39;max_width&#39; not in cat_max_dims[cat_id] else max(mod[2], cat_max_dims[cat_id][&#39;max_width&#39;])
        cat_max_dims[cat_id][&#39;max_height&#39;] = mod[3] if &#39;max_height&#39; not in cat_max_dims[cat_id] else max(mod[3], cat_max_dims[cat_id][&#39;max_height&#39;]) 
        cat_max_dims[cat_id][&#39;max_area&#39;] = cat_max_dims[cat_id][&#39;max_width&#39;]*cat_max_dims[cat_id][&#39;max_height&#39;]
    return cat_max_dims


start_time = time.time()

# Función principal que ejecuta el Smart Layout y su lógica
def Smart_Layout(dictionary, POP_SIZE, GENERATIONS, viz=False, viz_period=10):
    &#34;&#34;&#34;Main function that executes the Smart Layout and all its logic&#34;&#34;&#34;
    print(round(time.time() - start_time, 2), &#39;Start!&#39;)
    outline, holes, areas, input_list = get_input(dictionary)
    
    input_list = [[&#39;WYS_SALAREUNION_RECTA6PERSONAS&#39;,              0, 3, 4.05, 1],
                  [&#39;WYS_SALAREUNION_DIRECTORIO10PERSONAS&#39;,        1, 4, 6.05, 1],
                  [&#39;WYS_SALAREUNION_DIRECTORIO20PERSONAS&#39;,        1, 5.4, 6, 1],
                  [&#39;WYS_PUESTOTRABAJO_CELL3PERSONAS&#39;,             0, 3.37, 3.37, 2],
                  [&#39;WYS_PUESTOTRABAJO_RECTO2PERSONAS&#39;,            25, 3.82, 2.8, 2],
                  [&#39;WYS_PRIVADO_1PERSONA&#39;,                        2, 3.5, 2.8, 3],
                  [&#39;WYS_PRIVADO_1PERSONAESTAR&#39;,                   1, 6.4, 2.9, 3],
                  [&#39;WYS_SOPORTE_BAÑOBATERIAFEMENINO3PERSONAS&#39;,    0, 3.54, 3.02, 4],
                  [&#39;WYS_SOPORTE_BAÑOBATERIAMASCULINO3PERSONAS&#39;,   2, 3.54, 3.02, 4],
                  [&#39;WYS_SOPORTE_KITCHENETTE&#39;,                     1, 1.6, 2.3, 4],
                  [&#39;WYS_SOPORTE_SERVIDOR1BASTIDOR&#39;,               1, 1.5, 2.4, 4],
                  [&#39;WYS_SOPORTE_PRINT1&#39;,                          3, 1.5, 1.3, 4],
                  [&#39;WYS_RECEPCION_1PERSONA&#39;,                      1, 2.7, 3.25, 5],
                  [&#39;WYS_TRABAJOINDIVIDUAL_QUIETROOM2PERSONAS&#39;,    0, 2.05, 1.9, 5],
                  [&#39;WYS_TRABAJOINDIVIDUAL_PHONEBOOTH1PERSONA&#39;,    0, 2.05, 2.01, 5],
                  [&#39;WYS_COLABORATIVO_BARRA6PERSONAS&#39;,             0, 1.95, 2.4, 6],
                  [&#39;WYS_ESPECIALES_TALLERLABORATORIO4PERSONAS&#39;,   0, 4, 5, 7]]
    voids = []

    border = outline[0][1]
    for h in holes:
        voids.append(h[1])

    cat_area = {}

    # INPUT PARAMETERS
    N = 0  # number of modules to be placed in total
    for i in input_list:
        qty = i[1]
        N += qty
        total_area = qty*i[2]*i[3]
        cat_id = i[4]
        if qty &gt; 0:
            if cat_id in cat_area:
                cat_area[cat_id] += total_area
            else:
                cat_area[cat_id] = total_area
    #print(cat_area)
    cat_dims = get_category_max_dims(input_list)

    #min_cat_area, min_cat_key = min(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_area&#39;))
    max_cat_width, min_cat_key = max(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_width&#39;))
    max_cat_height, min_cat_key = max(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_height&#39;))
    
    max_dim = max(max_cat_width, max_cat_height)

    #print(&#39;cat_dims:&#39;, cat_dims)
    #print(&#39;max_dim:&#39;, max_dim)
    #print(&#34;min cat area, key&#34;, (min_cat_area, min_cat_key))
    #print(round(time.time() - start_time, 2), &#39;Load and compute all the inputs&#39;)
    #print(&#39;Number of modules: &#39;, N)
    # GA PARAMETERS
    IND_SIZE = N  # should be equal or very close to N

    planta = Polygon(border, voids)

    As = []
    shafts = []
    entrances = []
    crystal_facs = []
    for a in areas:
        As.append([Polygon(a[1]), a[0]])
        if a[0] == &#39;WYS_CORE&#39;:
            core = As[-1][0]
        if a[0] == &#39;WYS_SHAFT&#39;:
            shafts.append(As[-1][0])
        if a[0] == &#39;WYS_ENTRANCE&#39;:
            entrances.append(As[-1][0])
        if a[0] == &#39;WYS_FACADE_CRYSTAL&#39;:
            crystal_facs.append(As[-1][0])
    
    circ_width = 1.2
    circ_pols = make_circ_ring(planta, core, shafts, entrances, voids, circ_width)
    # areas = make_areas(planta, core)
    areas = get_area2(planta, core, circ_pols, min_dim_area=max_dim, proporcional=False)
    # areas = get_pol_zones(outline, voids, min_area=3, min_dim=3, boundbox_on_outline=False, boundbox_on_holes=True)
    # areas = get_pol_zones(outline, circ_voids_coords, min_area=min_cat_area, min_dim=min_cat_area, boundbox_on_outline=False, boundbox_on_holes=False)
    areas = merge_min_areas(areas, max_dim*3)

    def circ_buffer(circ_pols):
        &#34;&#34;&#34;Function that separates the polygons that make up the circulation&#34;&#34;&#34;
        circ_polygons = []
        for c in circ_pols:
            r_minx, r_miny, r_maxx, r_maxy = c.bounds
            line1 = LineString([(r_minx, r_miny), (r_minx, r_maxy)])
            line2 = LineString([(r_minx, r_maxy), (r_maxx, r_maxy)])
            line3 = LineString([(r_maxx, r_maxy), (r_maxx, r_miny)])
            line4 = LineString([(r_maxx, r_miny), (r_minx, r_miny)])
            if line1.length &gt; line2.length:
                line1_buf = substring(line1, start_dist=0.0001, end_dist=-0.0001)
                line3_buf = substring(line3, start_dist=0.0001, end_dist=-0.0001)
                l1_min, l1_max = line1_buf.boundary
                l3_max, l3_min = line3_buf.boundary
                rectan1 = Polygon([l1_min, l1_max, l3_max, l3_min, l1_min])
                circ_polygons.append(rectan1)
            elif line1.length &lt; line2.length:
                line2_buf = substring(line2, start_dist=0.0001, end_dist=-0.0001)
                line4_buf = substring(line4, start_dist=0.0001, end_dist=-0.0001)
                l2_min, l2_max = line2_buf.boundary
                l4_max, l4_min = line4_buf.boundary
                rectan2 = Polygon([l2_min, l2_max, l4_max, l4_min, l2_min])
                circ_polygons.append(rectan2)
            else:
                circ_polygons.append(c)
                #continue
        return circ_polygons

    circ_pols = circ_buffer(circ_pols)
    circ_voids_coords = merge_voids(voids, circ_pols)
    print(&#34;planta valida:&#34;, planta.is_valid)
    planta = Polygon(border, circ_voids_coords)
    print(&#34;planta valida:&#34;, planta.is_valid)
    zones = make_zones(planta, shafts, core, circ_voids_coords, entrances, crystal_facs, areas, cat_area, cat_dims)
    #zones = {}

    def mutMod(individual, planta, mu, sigma, indpb):
        minx, miny, maxx, maxy = planta.bounds
        for i in individual:

            if random.random() &lt; indpb:
                dx = round(random.gauss(mu, sigma), 1)
                i.x += dx
                if not planta.contains(i.get_box()):
                    if i.x &gt; maxx - i.width / 2:
                        i.x = round(maxx - i.width / 2 - 0.05, 1)
                    elif i.x &lt; minx + i.width / 2:
                        i.x = round(minx + i.width / 2 + 0.05, 1)

            if random.random() &lt; indpb:
                dy = round(random.gauss(mu, sigma), 1)
                i.y += dy
                if not planta.contains(i.get_box()):
                    if i.y &gt; maxy - i.height / 2:
                        i.y = round(maxy - i.height / 2 - 0.05, 1)
                    elif i.y &lt; miny + i.height / 2:
                        i.y = round(miny + i.height / 2 + 0.05, 1)

            if random.random() &lt; indpb:
                i.height, i.width = i.width, i.height
                i.rot += 90
                if not planta.contains(i.get_box()):
                    i.height, i.width = i.width, i.height
                    i.rot -= 90
                else:
                    if i.rot &gt;= 360:
                        i.rot = 0
            i.x, i.y = round(i.x, 1), round(i.y, 1)

        return individual,

    def acond_distance(d):
        return 10 * math.exp(-d / 3)
        #return d

    def notas_percent_mod2areas(valoracion, metros, area):
        # Evaluación de los módulos respecto a las entradas
        if area == &#39;WYS_ENTRANCE&#39; and valoracion &gt; 0:
            x1 = 1
            x2 = 5
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 100
            elif metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_ENTRANCE&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto a las ventanas
        if area == &#39;WYS_FACADE_CRYSTAL&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_FACADE_CRYSTAL&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 1
            if metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto al Shaft
        if area == &#39;WYS_SHAFT&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 0.5
            if metros &gt; 0.5:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_SHAFT&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto al Core
        if area == &#39;WYS_CORE&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_CORE&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        cumplimiento = round(cumplimiento, 2)
        return cumplimiento

    def notas_percent_mod2mod(valoracion, metros):
        # Evaluación de los módulos respecto a los demás módulos
        if valoracion &gt; 0:
            x1 = 1
            x2 = 2
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 100
            elif metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100

        if valoracion &lt; 0:
            x1 = 1
            x2 = 2
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 0
            elif metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        cumplimiento = round(cumplimiento, 2)
        return cumplimiento

    def evaluate_rules(As, ind):
        modulo = []
        for mod in ind:
            modulo.append([mod.get_box(), mod.name])
        nb = len(modulo)
        evaluacion_area = []; nota_total_area = []
        evaluacion_mod = [];  nota_total_mod = []

        # Se recorren todos los módulos
        for i in range(nb):
            # Distancia entre el módulo y las distintas áreas (la más cercana):
            bx_dist = []
            for A in As:
                bx_dist.append([A[1], modulo[i][0].distance(A[0]), i, i])
            mod_dist_areas = min_dist_to_area(bx_dist)

            notas_mod2areas = [0] * (len(mod_dist_areas) * 2 + 2)
            notas_mod2areas[0] = ind[i].id
            notas_mod2areas[1] = ind[i].name
            hl = 0
            for d in mod_dist_areas:
                w = restrictions.mod2area(restrictions.module_dictionary, restrictions.area_dictionary,
                                          restrictions.mod2area_matrix, modulo[i][1], d[0])
                notas_mod2areas[hl + 2] = d[0]
                notas_mod2areas[hl + 3] = nan
                if w != 0:
                    x_area = notas_percent_mod2areas(w, d[1], d[0])
                    notas_mod2areas[hl + 3] = x_area
                    nota_total_area.append(x_area)
                hl += 2
            evaluacion_area.append(notas_mod2areas)
            print(notas_mod2areas)

            distances = []
            for j in range(nb):
                # Distancia entre el módulo y los demás módulos (el más cercano de cada tipo):
                if i is not j:
                    distances.append([modulo[j][1], modulo[i][0].distance(modulo[j][0]), i, j])
            distances2 = min_dist_to_area(distances)
            notas_mod2mod = [0] * (len(distances2) * 2 + 2)
            notas_mod2mod[0] = ind[i].id
            notas_mod2mod[1] = ind[i].name
            hl = 0
            for d in distances2:
                w = restrictions.mod2mod(restrictions.module_dictionary, restrictions.mod2mod_matrix,
                                         modulo[i][1], d[0])
                notas_mod2mod[hl + 2] = nan
                notas_mod2mod[hl + 3] = nan
                if w != 0:
                    if modulo[i][0].intersects(modulo[(d[3])][0]):
                        x_mod = 0
                        notas_mod2mod[hl + 2] = d[0]
                        notas_mod2mod[hl + 3] = x_mod
                        nota_total_mod.append(x_mod)
                        print(&#39;Coliciona con el Módulo: &#39; + str(d[3]+1))
                    else:
                        x_mod = notas_percent_mod2mod(w, d[1])
                        notas_mod2mod[hl + 2] = d[0]
                        notas_mod2mod[hl + 3] = x_mod
                        nota_total_mod.append(x_mod)
                hl += 2
            evaluacion_mod.append(notas_mod2mod)
            print(notas_mod2mod)

        nota_prom_area = round(sum(nota_total_area)/len(nota_total_area))
        nota_prom_mod = round(sum(nota_total_mod) / len(nota_total_mod))
        print(&#39;Nota Area Promedio del Layout =   &#39; + str(nota_prom_area))
        print(&#39;Nota Modulo Promedio del Layout = &#39; + str(nota_prom_mod))
        return nota_prom_area, nota_prom_mod

    def modtoareas(As, ind):
        a = 0
        boxes = []
        for mod in ind:
            boxes.append([mod.get_box(), mod.name])
            mod.fitval1 = 0
            mod.fitval2 = 0

        nb = len(boxes)
        for i in range(nb):
            ind[i].id = i + 1
            bx_dist = []
            # Distancia entre el módulo y las distintas áreas (la más cercana):
            for A in As:
                bx_dist.append([A[1], boxes[i][0].distance(A[0]), i, i])
            bx_dist2 = min_dist_to_area(bx_dist)
            for d in bx_dist2:
                w = restrictions.mod2area(restrictions.module_dictionary, restrictions.area_dictionary,
                                          restrictions.mod2area_matrix, boxes[i][1], d[0])
                if w != 0:
                    #print(&#34;fitval1&#34;)
                    ind[i].fitval1 += round((acond_distance(d[1]) * w)/ind[i].qty, 2)
                    a += (acond_distance(d[1]) * w)/ind[i].qty

            distances = []
            for j in range(nb):
                if i is not j:
                    distances.append([boxes[j][1], boxes[i][0].distance(boxes[j][0]), i, j])
            distances2 = min_dist_to_area(distances)
            for d in distances2:
                w = restrictions.mod2mod(restrictions.module_dictionary, restrictions.mod2mod_matrix,
                                         boxes[i][1], d[0])
                if w != 0:
                    #print(&#34;fitval2&#34;)
                    ind[i].fitval2 += round((acond_distance(d[1]) * w)/ind[i].qty, 2)
                    a += (acond_distance(d[1]) * w)/ind[i].qty
        return a

    def evaluateInd(ind):
        pond = -10
        fit_list = []
        fit_list.append(modtoareas(As, ind))
        fit_list.append(pond * feas_distance(ind))
        a = sum(fit_list)
        return a,

    def evaluateBestInd(ind):
        pond = -20
        fit_list = []
        a, b, c = modtoareas(As, ind)
        fit_list.append(a)
        area = feas_distance(ind)
        fit_list.append(pond * area)
        a = sum(fit_list)
        print(&#39;Nota Area Promedio del Layout =   &#39; + str(b))
        print(&#39;Nota Modulo Promedio del Layout = &#39; + str(c))
        print(&#34;Feas Distance Area: &#34; + str(area))
        print(&#34;Evaluate Ind = &#34; + str(a))
        return a,

    def feas_distance(ind):
        # check for intermods collisions:
        area = 0
        boxes = []
        for mod in ind:
            boxes.append(
                [mod.get_box(),
                 mod.name])
        nb = len(boxes)
        for i in range(nb):
            if not planta.contains(boxes[i][0]):
                area += boxes[i][0].area - boxes[i][0].intersection(planta).area
            for j in range(i + 1, nb):
                if boxes[i][0].intersects(boxes[j][0]):
                    area += boxes[i][0].intersection(boxes[j][0]).area
        return area


    creator.create(&#34;FitnessMax&#34;, base.Fitness, weights=(1.0,))
    creator.create(&#34;Individual&#34;, list, fitness=creator.FitnessMax)

    toolbox = base.Toolbox()
    toolbox.register(&#34;attr_pos&#34;, makePos, planta, input_list, zones)
    toolbox.register(&#34;individual&#34;, tools.initRepeat, creator.Individual,
                     (toolbox.attr_pos), n=IND_SIZE)

    toolbox.register(&#34;mate&#34;, tools.cxTwoPoint)
    toolbox.register(&#34;mutate&#34;, mutMod, planta=planta, mu=0, sigma=0.5, indpb=0.2)
    toolbox.register(&#34;select_best&#34;, tools.selBest)
    toolbox.register(&#34;select_roulette&#34;, tools.selRoulette)
    toolbox.register(&#34;select&#34;, tools.selTournament, tournsize=3)
    # toolbox.register(&#34;select&#34;, tools.selTournament, tournsize=round(POP_SIZE*0.4))
    # toolbox.register(&#34;select&#34;, tools.selNSGA2)
    toolbox.register(&#34;evaluate&#34;, evaluateInd)

    toolbox.register(&#34;population&#34;, tools.initRepeat, list, toolbox.individual)
    # toolbox.decorate(&#34;evaluate&#34;, tools.DeltaPenalty(feasible, -10.0, feas_distance))

    # Init of the algorithm
    print(round(time.time() - start_time, 1), &#39;Generate population:&#39;)

    pop = toolbox.population(n=POP_SIZE)
    print(&#34;Cantidad de Población: &#34;+str(len(pop)))
    print(round(time.time() - start_time, 1), &#39;...Done&#39;)

    CXPB, MUTPB, NGEN = 0.5, 0.2, GENERATIONS

    # Evaluate the entire population
    fitnesses = map(toolbox.evaluate, pop)

    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit
        # print(&#39;Fitness Población Inicial: &#39;, round(fit[0], 2))

    fig, ax = viewer.viewer_viz(planta, As, viz, areas=areas, zones=zones)
    #fig, ax = viewer.viewer_viz(planta, As, viz)

    print(round(time.time() - start_time, 2), &#39;Start of genetic evolution:&#39;)

    max_count = 0
    max_fit = -9999999
    for g in range(NGEN):

        boxes = viewer.viz_update(viz, viz_period, g, pop, fig, ax)
        fitn = [o.fitness.values[0] for o in pop]
        print(&#39;Time:&#39;, round(time.time() - start_time, 1), &#39; Generation &#39;, g + 1, &#39;of&#39;, NGEN, &#39;POP SIZE:&#39;, len(pop),
              &#39;  Min:&#39;, round(min(fitn), 2), &#39;Max:&#39;, round(max(fitn), 2), &#39;Avg:&#39;, round(sum(fitn) / len(fitn), 1),
              &#39;Local sol. count:&#39;, max_count)

        if max(fitn) &lt; 0:
            CXPB = 0.1
            MUTPB = 0.6
        else:
            CXPB = 0.5
            MUTPB = 0.2
        # Select the next generation individuals
        offspring = toolbox.select(pop, len(pop))
        # Clone the selected individuals
        offspring = list(map(toolbox.clone, offspring))

        if pop[0]:
            # Apply crossover and mutation on the offspring
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() &lt; CXPB:  # probabilidad de mate?? mejor hacer que hagan mate si o si... linea de select
                    toolbox.mate(child1, child2)
                    del child1.fitness.values
                    del child2.fitness.values

            for mutant in offspring:
                if random.random() &lt; MUTPB:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values

            # Evaluate the individuals with an invalid fitness
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit

            #offspring = toolbox.select(offspring + pop, POP_SIZE)
            best_ind = toolbox.select_best(pop, k=int(POP_SIZE*0.4))
            pop[:] = offspring + best_ind

            pop.sort(key=lambda x: x.fitness, reverse=True)
            pop = pop[:POP_SIZE]

        # evaluateBestInd(pop[0])
        if (g + 1) == 1 or (g + 1) == NGEN:
            evaluate_rules(As, pop[0])
            print(&#39;Fitness = &#39;, pop[0].fitness.values)
            print(&#39;Tiempo Total Empleado: &#39;, round(time.time() - start_time, 1))
        viewer.viz_clear(viz, g, NGEN, viz_period, boxes)

    viewer.viz_end()
    print(round(time.time() - start_time, 1), &#39;Finish&#39;)
    print(&#39;Best individual of Generation&#39;, g + 1, &#39;:&#39;)
    out = []
    # pop.sort(key=lambda x: x.fitness, reverse=True)
    for mod in pop[0]:
        out.append([mod.name, mod.id, mod.x, mod.y, mod.rot])
        # print(mod.name, &#39;(&#39;, mod.x, &#39;,&#39;, mod.y, &#39;)&#39;, &#39;id:&#39;, mod.id, &#39;rot:&#39;, mod.rot)
    print(&#39;Fitness = &#39;, pop[0].fitness.values)
    # evaluateBestInd(pop[0])
    # evaluate_rules(As, pop[0])
    # viewer.show_floor(planta, As, pop, g)
    &#39;&#39;&#39;for o in out:
        print(o)&#39;&#39;&#39;

    return out</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SmartLayout.Smart_Layout"><code class="name flex">
<span>def <span class="ident">Smart_Layout</span></span>(<span>dictionary, POP_SIZE, GENERATIONS, viz=False, viz_period=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function that executes the Smart Layout and all its logic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Smart_Layout(dictionary, POP_SIZE, GENERATIONS, viz=False, viz_period=10):
    &#34;&#34;&#34;Main function that executes the Smart Layout and all its logic&#34;&#34;&#34;
    print(round(time.time() - start_time, 2), &#39;Start!&#39;)
    outline, holes, areas, input_list = get_input(dictionary)
    
    input_list = [[&#39;WYS_SALAREUNION_RECTA6PERSONAS&#39;,              0, 3, 4.05, 1],
                  [&#39;WYS_SALAREUNION_DIRECTORIO10PERSONAS&#39;,        1, 4, 6.05, 1],
                  [&#39;WYS_SALAREUNION_DIRECTORIO20PERSONAS&#39;,        1, 5.4, 6, 1],
                  [&#39;WYS_PUESTOTRABAJO_CELL3PERSONAS&#39;,             0, 3.37, 3.37, 2],
                  [&#39;WYS_PUESTOTRABAJO_RECTO2PERSONAS&#39;,            25, 3.82, 2.8, 2],
                  [&#39;WYS_PRIVADO_1PERSONA&#39;,                        2, 3.5, 2.8, 3],
                  [&#39;WYS_PRIVADO_1PERSONAESTAR&#39;,                   1, 6.4, 2.9, 3],
                  [&#39;WYS_SOPORTE_BAÑOBATERIAFEMENINO3PERSONAS&#39;,    0, 3.54, 3.02, 4],
                  [&#39;WYS_SOPORTE_BAÑOBATERIAMASCULINO3PERSONAS&#39;,   2, 3.54, 3.02, 4],
                  [&#39;WYS_SOPORTE_KITCHENETTE&#39;,                     1, 1.6, 2.3, 4],
                  [&#39;WYS_SOPORTE_SERVIDOR1BASTIDOR&#39;,               1, 1.5, 2.4, 4],
                  [&#39;WYS_SOPORTE_PRINT1&#39;,                          3, 1.5, 1.3, 4],
                  [&#39;WYS_RECEPCION_1PERSONA&#39;,                      1, 2.7, 3.25, 5],
                  [&#39;WYS_TRABAJOINDIVIDUAL_QUIETROOM2PERSONAS&#39;,    0, 2.05, 1.9, 5],
                  [&#39;WYS_TRABAJOINDIVIDUAL_PHONEBOOTH1PERSONA&#39;,    0, 2.05, 2.01, 5],
                  [&#39;WYS_COLABORATIVO_BARRA6PERSONAS&#39;,             0, 1.95, 2.4, 6],
                  [&#39;WYS_ESPECIALES_TALLERLABORATORIO4PERSONAS&#39;,   0, 4, 5, 7]]
    voids = []

    border = outline[0][1]
    for h in holes:
        voids.append(h[1])

    cat_area = {}

    # INPUT PARAMETERS
    N = 0  # number of modules to be placed in total
    for i in input_list:
        qty = i[1]
        N += qty
        total_area = qty*i[2]*i[3]
        cat_id = i[4]
        if qty &gt; 0:
            if cat_id in cat_area:
                cat_area[cat_id] += total_area
            else:
                cat_area[cat_id] = total_area
    #print(cat_area)
    cat_dims = get_category_max_dims(input_list)

    #min_cat_area, min_cat_key = min(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_area&#39;))
    max_cat_width, min_cat_key = max(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_width&#39;))
    max_cat_height, min_cat_key = max(((v1,k0) for k0,v0 in cat_dims.items() for k1,v1 in v0.items() if k1 == &#39;max_height&#39;))
    
    max_dim = max(max_cat_width, max_cat_height)

    #print(&#39;cat_dims:&#39;, cat_dims)
    #print(&#39;max_dim:&#39;, max_dim)
    #print(&#34;min cat area, key&#34;, (min_cat_area, min_cat_key))
    #print(round(time.time() - start_time, 2), &#39;Load and compute all the inputs&#39;)
    #print(&#39;Number of modules: &#39;, N)
    # GA PARAMETERS
    IND_SIZE = N  # should be equal or very close to N

    planta = Polygon(border, voids)

    As = []
    shafts = []
    entrances = []
    crystal_facs = []
    for a in areas:
        As.append([Polygon(a[1]), a[0]])
        if a[0] == &#39;WYS_CORE&#39;:
            core = As[-1][0]
        if a[0] == &#39;WYS_SHAFT&#39;:
            shafts.append(As[-1][0])
        if a[0] == &#39;WYS_ENTRANCE&#39;:
            entrances.append(As[-1][0])
        if a[0] == &#39;WYS_FACADE_CRYSTAL&#39;:
            crystal_facs.append(As[-1][0])
    
    circ_width = 1.2
    circ_pols = make_circ_ring(planta, core, shafts, entrances, voids, circ_width)
    # areas = make_areas(planta, core)
    areas = get_area2(planta, core, circ_pols, min_dim_area=max_dim, proporcional=False)
    # areas = get_pol_zones(outline, voids, min_area=3, min_dim=3, boundbox_on_outline=False, boundbox_on_holes=True)
    # areas = get_pol_zones(outline, circ_voids_coords, min_area=min_cat_area, min_dim=min_cat_area, boundbox_on_outline=False, boundbox_on_holes=False)
    areas = merge_min_areas(areas, max_dim*3)

    def circ_buffer(circ_pols):
        &#34;&#34;&#34;Function that separates the polygons that make up the circulation&#34;&#34;&#34;
        circ_polygons = []
        for c in circ_pols:
            r_minx, r_miny, r_maxx, r_maxy = c.bounds
            line1 = LineString([(r_minx, r_miny), (r_minx, r_maxy)])
            line2 = LineString([(r_minx, r_maxy), (r_maxx, r_maxy)])
            line3 = LineString([(r_maxx, r_maxy), (r_maxx, r_miny)])
            line4 = LineString([(r_maxx, r_miny), (r_minx, r_miny)])
            if line1.length &gt; line2.length:
                line1_buf = substring(line1, start_dist=0.0001, end_dist=-0.0001)
                line3_buf = substring(line3, start_dist=0.0001, end_dist=-0.0001)
                l1_min, l1_max = line1_buf.boundary
                l3_max, l3_min = line3_buf.boundary
                rectan1 = Polygon([l1_min, l1_max, l3_max, l3_min, l1_min])
                circ_polygons.append(rectan1)
            elif line1.length &lt; line2.length:
                line2_buf = substring(line2, start_dist=0.0001, end_dist=-0.0001)
                line4_buf = substring(line4, start_dist=0.0001, end_dist=-0.0001)
                l2_min, l2_max = line2_buf.boundary
                l4_max, l4_min = line4_buf.boundary
                rectan2 = Polygon([l2_min, l2_max, l4_max, l4_min, l2_min])
                circ_polygons.append(rectan2)
            else:
                circ_polygons.append(c)
                #continue
        return circ_polygons

    circ_pols = circ_buffer(circ_pols)
    circ_voids_coords = merge_voids(voids, circ_pols)
    print(&#34;planta valida:&#34;, planta.is_valid)
    planta = Polygon(border, circ_voids_coords)
    print(&#34;planta valida:&#34;, planta.is_valid)
    zones = make_zones(planta, shafts, core, circ_voids_coords, entrances, crystal_facs, areas, cat_area, cat_dims)
    #zones = {}

    def mutMod(individual, planta, mu, sigma, indpb):
        minx, miny, maxx, maxy = planta.bounds
        for i in individual:

            if random.random() &lt; indpb:
                dx = round(random.gauss(mu, sigma), 1)
                i.x += dx
                if not planta.contains(i.get_box()):
                    if i.x &gt; maxx - i.width / 2:
                        i.x = round(maxx - i.width / 2 - 0.05, 1)
                    elif i.x &lt; minx + i.width / 2:
                        i.x = round(minx + i.width / 2 + 0.05, 1)

            if random.random() &lt; indpb:
                dy = round(random.gauss(mu, sigma), 1)
                i.y += dy
                if not planta.contains(i.get_box()):
                    if i.y &gt; maxy - i.height / 2:
                        i.y = round(maxy - i.height / 2 - 0.05, 1)
                    elif i.y &lt; miny + i.height / 2:
                        i.y = round(miny + i.height / 2 + 0.05, 1)

            if random.random() &lt; indpb:
                i.height, i.width = i.width, i.height
                i.rot += 90
                if not planta.contains(i.get_box()):
                    i.height, i.width = i.width, i.height
                    i.rot -= 90
                else:
                    if i.rot &gt;= 360:
                        i.rot = 0
            i.x, i.y = round(i.x, 1), round(i.y, 1)

        return individual,

    def acond_distance(d):
        return 10 * math.exp(-d / 3)
        #return d

    def notas_percent_mod2areas(valoracion, metros, area):
        # Evaluación de los módulos respecto a las entradas
        if area == &#39;WYS_ENTRANCE&#39; and valoracion &gt; 0:
            x1 = 1
            x2 = 5
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 100
            elif metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_ENTRANCE&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto a las ventanas
        if area == &#39;WYS_FACADE_CRYSTAL&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_FACADE_CRYSTAL&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 1
            if metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto al Shaft
        if area == &#39;WYS_SHAFT&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 0.5
            if metros &gt; 0.5:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_SHAFT&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        # Evaluación de los módulos respecto al Core
        if area == &#39;WYS_CORE&#39; and valoracion &gt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100
        if area == &#39;WYS_CORE&#39; and valoracion &lt; 0:
            x1 = 0
            x2 = 3
            if metros &gt; 3:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        cumplimiento = round(cumplimiento, 2)
        return cumplimiento

    def notas_percent_mod2mod(valoracion, metros):
        # Evaluación de los módulos respecto a los demás módulos
        if valoracion &gt; 0:
            x1 = 1
            x2 = 2
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 100
            elif metros &gt; x2:
                cumplimiento = 0
            else:
                cumplimiento = ((0-100)/(x2-x1)) * (metros - x1) + 100

        if valoracion &lt; 0:
            x1 = 1
            x2 = 2
            if 0 &lt;= metros &lt; x1:
                cumplimiento = 0
            elif metros &gt; x2:
                cumplimiento = 100
            else:
                cumplimiento = ((100-0)/(x2-x1)) * (metros - x1)

        cumplimiento = round(cumplimiento, 2)
        return cumplimiento

    def evaluate_rules(As, ind):
        modulo = []
        for mod in ind:
            modulo.append([mod.get_box(), mod.name])
        nb = len(modulo)
        evaluacion_area = []; nota_total_area = []
        evaluacion_mod = [];  nota_total_mod = []

        # Se recorren todos los módulos
        for i in range(nb):
            # Distancia entre el módulo y las distintas áreas (la más cercana):
            bx_dist = []
            for A in As:
                bx_dist.append([A[1], modulo[i][0].distance(A[0]), i, i])
            mod_dist_areas = min_dist_to_area(bx_dist)

            notas_mod2areas = [0] * (len(mod_dist_areas) * 2 + 2)
            notas_mod2areas[0] = ind[i].id
            notas_mod2areas[1] = ind[i].name
            hl = 0
            for d in mod_dist_areas:
                w = restrictions.mod2area(restrictions.module_dictionary, restrictions.area_dictionary,
                                          restrictions.mod2area_matrix, modulo[i][1], d[0])
                notas_mod2areas[hl + 2] = d[0]
                notas_mod2areas[hl + 3] = nan
                if w != 0:
                    x_area = notas_percent_mod2areas(w, d[1], d[0])
                    notas_mod2areas[hl + 3] = x_area
                    nota_total_area.append(x_area)
                hl += 2
            evaluacion_area.append(notas_mod2areas)
            print(notas_mod2areas)

            distances = []
            for j in range(nb):
                # Distancia entre el módulo y los demás módulos (el más cercano de cada tipo):
                if i is not j:
                    distances.append([modulo[j][1], modulo[i][0].distance(modulo[j][0]), i, j])
            distances2 = min_dist_to_area(distances)
            notas_mod2mod = [0] * (len(distances2) * 2 + 2)
            notas_mod2mod[0] = ind[i].id
            notas_mod2mod[1] = ind[i].name
            hl = 0
            for d in distances2:
                w = restrictions.mod2mod(restrictions.module_dictionary, restrictions.mod2mod_matrix,
                                         modulo[i][1], d[0])
                notas_mod2mod[hl + 2] = nan
                notas_mod2mod[hl + 3] = nan
                if w != 0:
                    if modulo[i][0].intersects(modulo[(d[3])][0]):
                        x_mod = 0
                        notas_mod2mod[hl + 2] = d[0]
                        notas_mod2mod[hl + 3] = x_mod
                        nota_total_mod.append(x_mod)
                        print(&#39;Coliciona con el Módulo: &#39; + str(d[3]+1))
                    else:
                        x_mod = notas_percent_mod2mod(w, d[1])
                        notas_mod2mod[hl + 2] = d[0]
                        notas_mod2mod[hl + 3] = x_mod
                        nota_total_mod.append(x_mod)
                hl += 2
            evaluacion_mod.append(notas_mod2mod)
            print(notas_mod2mod)

        nota_prom_area = round(sum(nota_total_area)/len(nota_total_area))
        nota_prom_mod = round(sum(nota_total_mod) / len(nota_total_mod))
        print(&#39;Nota Area Promedio del Layout =   &#39; + str(nota_prom_area))
        print(&#39;Nota Modulo Promedio del Layout = &#39; + str(nota_prom_mod))
        return nota_prom_area, nota_prom_mod

    def modtoareas(As, ind):
        a = 0
        boxes = []
        for mod in ind:
            boxes.append([mod.get_box(), mod.name])
            mod.fitval1 = 0
            mod.fitval2 = 0

        nb = len(boxes)
        for i in range(nb):
            ind[i].id = i + 1
            bx_dist = []
            # Distancia entre el módulo y las distintas áreas (la más cercana):
            for A in As:
                bx_dist.append([A[1], boxes[i][0].distance(A[0]), i, i])
            bx_dist2 = min_dist_to_area(bx_dist)
            for d in bx_dist2:
                w = restrictions.mod2area(restrictions.module_dictionary, restrictions.area_dictionary,
                                          restrictions.mod2area_matrix, boxes[i][1], d[0])
                if w != 0:
                    #print(&#34;fitval1&#34;)
                    ind[i].fitval1 += round((acond_distance(d[1]) * w)/ind[i].qty, 2)
                    a += (acond_distance(d[1]) * w)/ind[i].qty

            distances = []
            for j in range(nb):
                if i is not j:
                    distances.append([boxes[j][1], boxes[i][0].distance(boxes[j][0]), i, j])
            distances2 = min_dist_to_area(distances)
            for d in distances2:
                w = restrictions.mod2mod(restrictions.module_dictionary, restrictions.mod2mod_matrix,
                                         boxes[i][1], d[0])
                if w != 0:
                    #print(&#34;fitval2&#34;)
                    ind[i].fitval2 += round((acond_distance(d[1]) * w)/ind[i].qty, 2)
                    a += (acond_distance(d[1]) * w)/ind[i].qty
        return a

    def evaluateInd(ind):
        pond = -10
        fit_list = []
        fit_list.append(modtoareas(As, ind))
        fit_list.append(pond * feas_distance(ind))
        a = sum(fit_list)
        return a,

    def evaluateBestInd(ind):
        pond = -20
        fit_list = []
        a, b, c = modtoareas(As, ind)
        fit_list.append(a)
        area = feas_distance(ind)
        fit_list.append(pond * area)
        a = sum(fit_list)
        print(&#39;Nota Area Promedio del Layout =   &#39; + str(b))
        print(&#39;Nota Modulo Promedio del Layout = &#39; + str(c))
        print(&#34;Feas Distance Area: &#34; + str(area))
        print(&#34;Evaluate Ind = &#34; + str(a))
        return a,

    def feas_distance(ind):
        # check for intermods collisions:
        area = 0
        boxes = []
        for mod in ind:
            boxes.append(
                [mod.get_box(),
                 mod.name])
        nb = len(boxes)
        for i in range(nb):
            if not planta.contains(boxes[i][0]):
                area += boxes[i][0].area - boxes[i][0].intersection(planta).area
            for j in range(i + 1, nb):
                if boxes[i][0].intersects(boxes[j][0]):
                    area += boxes[i][0].intersection(boxes[j][0]).area
        return area


    creator.create(&#34;FitnessMax&#34;, base.Fitness, weights=(1.0,))
    creator.create(&#34;Individual&#34;, list, fitness=creator.FitnessMax)

    toolbox = base.Toolbox()
    toolbox.register(&#34;attr_pos&#34;, makePos, planta, input_list, zones)
    toolbox.register(&#34;individual&#34;, tools.initRepeat, creator.Individual,
                     (toolbox.attr_pos), n=IND_SIZE)

    toolbox.register(&#34;mate&#34;, tools.cxTwoPoint)
    toolbox.register(&#34;mutate&#34;, mutMod, planta=planta, mu=0, sigma=0.5, indpb=0.2)
    toolbox.register(&#34;select_best&#34;, tools.selBest)
    toolbox.register(&#34;select_roulette&#34;, tools.selRoulette)
    toolbox.register(&#34;select&#34;, tools.selTournament, tournsize=3)
    # toolbox.register(&#34;select&#34;, tools.selTournament, tournsize=round(POP_SIZE*0.4))
    # toolbox.register(&#34;select&#34;, tools.selNSGA2)
    toolbox.register(&#34;evaluate&#34;, evaluateInd)

    toolbox.register(&#34;population&#34;, tools.initRepeat, list, toolbox.individual)
    # toolbox.decorate(&#34;evaluate&#34;, tools.DeltaPenalty(feasible, -10.0, feas_distance))

    # Init of the algorithm
    print(round(time.time() - start_time, 1), &#39;Generate population:&#39;)

    pop = toolbox.population(n=POP_SIZE)
    print(&#34;Cantidad de Población: &#34;+str(len(pop)))
    print(round(time.time() - start_time, 1), &#39;...Done&#39;)

    CXPB, MUTPB, NGEN = 0.5, 0.2, GENERATIONS

    # Evaluate the entire population
    fitnesses = map(toolbox.evaluate, pop)

    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit
        # print(&#39;Fitness Población Inicial: &#39;, round(fit[0], 2))

    fig, ax = viewer.viewer_viz(planta, As, viz, areas=areas, zones=zones)
    #fig, ax = viewer.viewer_viz(planta, As, viz)

    print(round(time.time() - start_time, 2), &#39;Start of genetic evolution:&#39;)

    max_count = 0
    max_fit = -9999999
    for g in range(NGEN):

        boxes = viewer.viz_update(viz, viz_period, g, pop, fig, ax)
        fitn = [o.fitness.values[0] for o in pop]
        print(&#39;Time:&#39;, round(time.time() - start_time, 1), &#39; Generation &#39;, g + 1, &#39;of&#39;, NGEN, &#39;POP SIZE:&#39;, len(pop),
              &#39;  Min:&#39;, round(min(fitn), 2), &#39;Max:&#39;, round(max(fitn), 2), &#39;Avg:&#39;, round(sum(fitn) / len(fitn), 1),
              &#39;Local sol. count:&#39;, max_count)

        if max(fitn) &lt; 0:
            CXPB = 0.1
            MUTPB = 0.6
        else:
            CXPB = 0.5
            MUTPB = 0.2
        # Select the next generation individuals
        offspring = toolbox.select(pop, len(pop))
        # Clone the selected individuals
        offspring = list(map(toolbox.clone, offspring))

        if pop[0]:
            # Apply crossover and mutation on the offspring
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() &lt; CXPB:  # probabilidad de mate?? mejor hacer que hagan mate si o si... linea de select
                    toolbox.mate(child1, child2)
                    del child1.fitness.values
                    del child2.fitness.values

            for mutant in offspring:
                if random.random() &lt; MUTPB:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values

            # Evaluate the individuals with an invalid fitness
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit

            #offspring = toolbox.select(offspring + pop, POP_SIZE)
            best_ind = toolbox.select_best(pop, k=int(POP_SIZE*0.4))
            pop[:] = offspring + best_ind

            pop.sort(key=lambda x: x.fitness, reverse=True)
            pop = pop[:POP_SIZE]

        # evaluateBestInd(pop[0])
        if (g + 1) == 1 or (g + 1) == NGEN:
            evaluate_rules(As, pop[0])
            print(&#39;Fitness = &#39;, pop[0].fitness.values)
            print(&#39;Tiempo Total Empleado: &#39;, round(time.time() - start_time, 1))
        viewer.viz_clear(viz, g, NGEN, viz_period, boxes)

    viewer.viz_end()
    print(round(time.time() - start_time, 1), &#39;Finish&#39;)
    print(&#39;Best individual of Generation&#39;, g + 1, &#39;:&#39;)
    out = []
    # pop.sort(key=lambda x: x.fitness, reverse=True)
    for mod in pop[0]:
        out.append([mod.name, mod.id, mod.x, mod.y, mod.rot])
        # print(mod.name, &#39;(&#39;, mod.x, &#39;,&#39;, mod.y, &#39;)&#39;, &#39;id:&#39;, mod.id, &#39;rot:&#39;, mod.rot)
    print(&#39;Fitness = &#39;, pop[0].fitness.values)
    # evaluateBestInd(pop[0])
    # evaluate_rules(As, pop[0])
    # viewer.show_floor(planta, As, pop, g)
    &#39;&#39;&#39;for o in out:
        print(o)&#39;&#39;&#39;

    return out</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_esp_zone"><code class="name flex">
<span>def <span class="ident">assign_esp_zone</span></span>(<span>sp_nearest_idx, elements_idx, cat_area, factor, esp_selected_zone, esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns the zones of special zones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_esp_zone(sp_nearest_idx, elements_idx, cat_area, factor, esp_selected_zone, 
                    esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns the zones of special zones&#34;&#34;&#34;
    if sp_nearest_idx:
        esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not esp_candidate_idx:
            esp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0 and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not esp_candidate_idx:
                esp_candidate_idx = [k for k, v in core_adj_qty.items() if v == max(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not esp_candidate_idx:
                    esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                    if not esp_candidate_idx:
                        esp_candidate_idx = [k for k,v in areas.items() if k in sp_nearest_idx]
                        if not esp_candidate_idx:
                            esp_candidate_idx = [k for k,v in areas.items()]
    else:
        esp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0 and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not esp_candidate_idx:
            esp_candidate_idx = [k for k, v in core_adj_qty.items() if v == max(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not esp_candidate_idx:
                esp_candidate_idx = [k for k,v in areas.items() if feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not esp_candidate_idx:
                    esp_candidate_idx = [k for k,v in areas.items()]

    #print(&#34;Candidatos especiales:&#34;, esp_candidate_idx)
    if len(esp_candidate_idx) &gt; 0:
        if len(esp_candidate_idx) &gt; 1:
            esp_candidate_zones = {}
            for c in esp_candidate_idx:
                esp_candidate_zones[c] = areas[c]
            esp_candidate_zones_areas = {k: v.area for k, v in esp_candidate_zones.items()}
            esp_selected_zone_idx = max(esp_candidate_zones_areas, key=esp_candidate_zones_areas.get)
            esp_selected_zone = esp_candidate_zones[esp_selected_zone_idx]
        elif len(esp_candidate_idx) == 1:
            esp_selected_zone_idx = esp_candidate_idx[0]
            esp_selected_zone = areas[esp_selected_zone_idx]
        
        areas.pop(esp_selected_zone_idx, None)
        shafts_adj_qty.pop(esp_selected_zone_idx, None)
        crystal_adj_qty.pop(esp_selected_zone_idx, None)
        entrances_adj_qty.pop(esp_selected_zone_idx, None)
        core_adj_qty.pop(esp_selected_zone_idx, None)
        esp_banned_idx = []
        while esp_selected_zone.area &lt; cat_area[7] + factor*cat_area[7] and len(areas) &gt; 0:
            esp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(esp_selected_zone.bounds, objects=True))))
            esp_nearest_idx = [k for k,v in areas.items() if v.bounds in esp_nearest and not k in esp_banned_idx]
            nearest_len = {idx: esp_selected_zone.intersection(areas[idx]).length for idx in esp_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                esp_candidate_zone = unary_union([esp_selected_zone, areas[nearest_candidate_idx]])
                if esp_selected_zone.geom_type == &#39;Polygon&#39; and (esp_candidate_zone.area / esp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    esp_selected_zone = esp_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    esp_banned_idx = []
                else:
                    esp_banned_idx.append(nearest_candidate_idx)
            else:
                break
        zones[&#39;ZONA ESPECIALES 0&#39;] = esp_selected_zone
        esp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(esp_selected_zone.bounds, objects=True))))
        esp_nearest_idx = [k for k,v in areas.items() if v.bounds in esp_nearest]
    
    return esp_selected_zone, esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_pt_zones"><code class="name flex">
<span>def <span class="ident">assign_pt_zones</span></span>(<span>has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone, sv_nearest_idx, pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns workstation zones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_pt_zones(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone,
                    sv_nearest_idx, pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns workstation zones&#34;&#34;&#34;
    pt_candidate_idx = []
    &#39;&#39;&#39;if sv_selected_zone:
        # Arreglo de indices de zonas cercanas al area de servicios
        if has_shaft:
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and (shafts_adj_qty[k] &gt; 0 or k in sv_nearest_idx)]
        else:
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and k in sv_nearest_idx]
    if not pt_candidate_idx:
        pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values())]&#39;&#39;&#39;
    pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    pt_candidate_zones = {}
    #print(&#34;Candidatos puestos de trabajo:&#34;, pt_candidate_idx)

    if len(pt_candidate_idx) &gt; 0:
        # Se asume que hay al menos 1 zona con muchas fachadas de cristal cercanas
        for c in pt_candidate_idx:
            pt_candidate_zones[c] = areas[c]
        if len(pt_candidate_zones) &lt; 2:
            # Si hay una zona con area maxima absoluta, se selecciona la primera zona siguiente que tenga area maxima
            pt_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and v &lt;= max(crystal_adj_qty.values()) and not k in pt_candidate_idx and feasible_polygon(cat_dims, areas[k])]
            pt_candidate_zones[pt_candidate_idx[0]] = areas[pt_candidate_idx[0]]
        # Se seleccionan solo 2 zonas de la lista de candidatas
        pt_selected_zones = []
        for i in range(2):
            pt_candidate_zones_areas = {k: v.area for k, v in pt_candidate_zones.items()}
            selected_zone_idx = max(pt_candidate_zones_areas, key=pt_candidate_zones_areas.get)
            selected_zone = pt_candidate_zones[selected_zone_idx]
            pt_selected_zones.append(selected_zone)
            #zones.append([selected_zone, &#39;ZONA PUESTOS DE TRABAJO&#39;])
            del pt_candidate_zones[selected_zone_idx]
            del pt_candidate_zones_areas[selected_zone_idx]
            areas.pop(selected_zone_idx, None)
            shafts_adj_qty.pop(selected_zone_idx, None)
            crystal_adj_qty.pop(selected_zone_idx, None)
            entrances_adj_qty.pop(selected_zone_idx, None)
            core_adj_qty.pop(selected_zone_idx, None)
        selector = False
        stuck_z0 = False
        stuck_z1 = False

        pt0_banned_idx = []
        pt1_banned_idx = []
        while pt_selected_zones[0].area + pt_selected_zones[1].area &lt; cat_area[2] + factor*cat_area[2] and len(areas) &gt; 0:
            if selector:
                pt_selected_zone = pt_selected_zones[1]
                pt_banned_idx = pt1_banned_idx
            else:
                pt_selected_zone = pt_selected_zones[0]
                pt_banned_idx = pt0_banned_idx
            pt_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(pt_selected_zone.bounds, objects=True))))
            pt_nearest_idx = [k for k,v in areas.items() if v.bounds in pt_nearest and not k in pt_banned_idx]
            pt_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in pt_nearest_idx]
            if pt_nearest_idx_filter:
                pt_nearest_idx = pt_nearest_idx_filter
            nearest_len = {idx: pt_selected_zone.intersection(areas[idx]).length for idx in pt_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                pt_candidate_zone = unary_union([pt_selected_zone, areas[nearest_candidate_idx]])
                if pt_candidate_zone.geom_type == &#39;Polygon&#39; and (pt_candidate_zone.area / pt_candidate_zone.minimum_rotated_rectangle.area) &gt; .80:
                    if selector:
                        pt_selected_zones[1] = pt_candidate_zone
                        pt1_banned_idx = []
                    else:
                        pt_selected_zones[0] = pt_candidate_zone
                        pt0_banned_idx = []
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                elif selector:
                    pt1_banned_idx.append(nearest_candidate_idx)
                else:
                    pt0_banned_idx.append(nearest_candidate_idx)

            elif stuck_z0 and stuck_z1:
                break
            elif selector:
                stuck_z1 = True
            else:
                stuck_z0 = True
            selector = not selector

        pt_nearest_idx = []
        for i in range(len(pt_selected_zones)):
            zones[&#39;ZONA PUESTOS DE TRABAJO &#39; + str(i)] = pt_selected_zones[i]
            pt_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(pt_selected_zones[i].bounds, objects=True))))
            for k,v in areas.items():
                if v.bounds in pt_nearest and not k in pt_nearest_idx:
                    pt_nearest_idx.append(k)
            for circ in circs_bounds:
                if pt_selected_zones[i].intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in pt_nearest_idx]
                    pt_nearest_idx += circ_nearest_idx

    return pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_ptp_zone"><code class="name flex">
<span>def <span class="ident">assign_ptp_zone</span></span>(<span>circs_bounds, sv_selected_zone, sv_nearest_idx, sp_selected_zone, sp_nearest_idx, elements_idx, cat_area, factor, ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns private work zones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_ptp_zone(circs_bounds, sv_selected_zone, sv_nearest_idx, sp_selected_zone, sp_nearest_idx, elements_idx, 
                    cat_area, factor, ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, 
                    crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns private work zones&#34;&#34;&#34;
    # Indices de areas cercanas a zona de soporte
    if sp_selected_zone and sv_selected_zone:
        # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and (not k in sp_nearest_idx and not k in sv_nearest_idx) and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            # En caso que NO se haya encontrado a lo menos un candidato que cumpla con el criterio, se relaja la restriccion
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and (not k in sp_nearest_idx or not k in sv_nearest_idx) and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
                if not ptp_candidate_idx:
                    ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    elif sp_selected_zone:
        # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sp_nearest_idx and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    elif sv_selected_zone:
            # Se buscan candidatos que tengan fachadas de cristal adyacentes y que no esten cerca de la zona de soporte
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and not k in sv_nearest_idx and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if not k in sv_nearest_idx and feasible_polygon(cat_dims, areas[k])]
            if not ptp_candidate_idx:
                ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    else:
        ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
        if not ptp_candidate_idx:
            ptp_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt;= min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k])]
    
    #print(&#34;Candidatos puestos de trabajo privado:&#34;)
    #print(ptp_candidate_idx)
    if len(ptp_candidate_idx) &gt; 0:
        # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el que tenga mas fachadas de cristal
        if len(ptp_candidate_idx) &gt; 1:
            ptp_candidate_zones = {}
            for c in ptp_candidate_idx:
                ptp_candidate_zones[c] = areas[c]
            ptp_candidate_zones_areas = {k: v.area for k, v in ptp_candidate_zones.items() if crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())}
            ptp_selected_zone_idx = max(ptp_candidate_zones_areas, key=ptp_candidate_zones_areas.get)
            ptp_selected_zone = ptp_candidate_zones[ptp_selected_zone_idx]
        elif len(ptp_candidate_idx) == 1:
            ptp_selected_zone_idx = ptp_candidate_idx[0]
            ptp_selected_zone = areas[ptp_selected_zone_idx]
        areas.pop(ptp_selected_zone_idx, None)
        shafts_adj_qty.pop(ptp_selected_zone_idx, None)
        crystal_adj_qty.pop(ptp_selected_zone_idx, None)
        entrances_adj_qty.pop(ptp_selected_zone_idx, None)
        core_adj_qty.pop(ptp_selected_zone_idx, None)
        ptp_banned_idx = []
        while ptp_selected_zone.area &lt; cat_area[3] + factor*cat_area[3] and len(areas) &gt; 0:
            ptp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(ptp_selected_zone.bounds, objects=True))))
            ptp_nearest_idx = [k for k,v in areas.items() if v.bounds in ptp_nearest and not k in ptp_banned_idx]
            ptp_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in ptp_nearest_idx]
            if ptp_nearest_idx_filter:
                ptp_nearest_idx = ptp_nearest_idx_filter
            nearest_len = {idx: ptp_selected_zone.intersection(areas[idx]).length for idx in ptp_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                ptp_candidate_zone = unary_union([ptp_selected_zone, areas[nearest_candidate_idx]])
                if ptp_candidate_zone.geom_type == &#39;Polygon&#39; and (ptp_candidate_zone.area / ptp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90 and feasible_polygon(cat_dims, ptp_candidate_zone.minimum_rotated_rectangle):
                    ptp_selected_zone = ptp_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    ptp_banned_idx = []
                else:
                    ptp_banned_idx.append(nearest_candidate_idx)
            else:
                break
        zones[&#39;ZONA TRABAJO PRIVADO 0&#39;] = ptp_selected_zone
        ptp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(ptp_selected_zone.bounds, objects=True))))
        ptp_nearest_idx = [k for k,v in areas.items() if v.bounds in ptp_nearest]
        for circ in circs_bounds:
            if ptp_selected_zone.intersects(box(*circ)):
                circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in ptp_nearest_idx]
                ptp_nearest_idx += circ_nearest_idx

    return ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_rf_zone"><code class="name flex">
<span>def <span class="ident">assign_rf_zone</span></span>(<span>sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx, elements_idx, cat_area, factor, prev_rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that maps the zones of formal meeting rooms</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                    elements_idx, cat_area, factor, prev_rf_selected_zone, rf_nearest_idx,
                    areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones):
    &#34;&#34;&#34;Function that maps the zones of formal meeting rooms&#34;&#34;&#34;
    nearest_len = None
    if ptp_selected_zone:
        # Se buscan indices de areas disponibles cercanas a la zona seleccionada como trabajo privado
        if sp_nearest_idx and sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx) and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx or not k in sv_nearest_idx) and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sp_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and k in ptp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and k in ptp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        else:
            rf_candidate_idx = [k for k, v in areas.items() if k in ptp_nearest_idx]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        rf_candidate_len = {idx: ptp_selected_zone.intersection(areas[idx]).length for idx in rf_candidate_idx if ptp_selected_zone.intersection(areas[idx]).geom_type == &#39;LineString&#39; or ptp_selected_zone.intersection(areas[idx]).geom_type == &#39;MultiLineString&#39;}
    else:
        if sp_nearest_idx and sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx) and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())] 
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx and not k in sv_nearest_idx)] 
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in areas.items() if (not k in sp_nearest_idx or not k in sv_nearest_idx)]
                    if not rf_candidate_idx:
                        rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sp_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sp_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        elif sv_nearest_idx:
            rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx and crystal_adj_qty[k] &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items() if not k in sv_nearest_idx]
                if not rf_candidate_idx:
                    rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
        else:
            rf_candidate_idx = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values())]
            if not rf_candidate_idx:
                rf_candidate_idx = [k for k, v in areas.items()]
    
    #print(&#34;Candidatos reuniones formales:&#34;)
    #print(rf_candidate_idx)
    rf_candidate_zones = {}
    if len(rf_candidate_idx) &gt; 0:
        # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el de mayor area
        if len(rf_candidate_idx) &gt; 1:
            if rf_candidate_len:
                rf_selected_zone_idx = max(rf_candidate_len, key=rf_candidate_len.get)
                rf_selected_zone = areas[rf_selected_zone_idx]
            else:
                for c in rf_candidate_idx:
                    rf_candidate_zones[c] = areas[c]
                rf_candidate_zones_areas = {k: v.area for k, v in rf_candidate_zones.items()}
                rf_selected_zone_idx = max(rf_candidate_zones_areas, key=rf_candidate_zones_areas.get)
                rf_selected_zone = rf_candidate_zones[rf_selected_zone_idx]
        elif len(rf_candidate_idx) == 1:
            rf_selected_zone_idx = rf_candidate_idx[0]
            rf_selected_zone = areas[rf_selected_zone_idx]

        areas.pop(rf_selected_zone_idx, None)
        shafts_adj_qty.pop(rf_selected_zone_idx, None)
        crystal_adj_qty.pop(rf_selected_zone_idx, None)
        entrances_adj_qty.pop(rf_selected_zone_idx, None)
        core_adj_qty.pop(rf_selected_zone_idx, None)
        rf_banned_idx = []
        if prev_rf_selected_zone:
            prev_area = prev_rf_selected_zone.area
        else:
            prev_area = 0
        while rf_selected_zone.area + prev_area &lt; cat_area[1] + factor*cat_area[1]:
            rf_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(rf_selected_zone.bounds, objects=True))))
            rf_nearest_idx = [k for k,v in areas.items() if v.bounds in rf_nearest and not k in rf_banned_idx]
            rf_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v &gt; min(crystal_adj_qty.values()) and k in rf_nearest_idx]
            if rf_nearest_idx_filter:
                rf_nearest_idx = rf_nearest_idx_filter
            nearest_len = {idx: rf_selected_zone.intersection(areas[idx]).length for idx in rf_nearest_idx}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                rf_candidate_zone = unary_union([rf_selected_zone, areas[nearest_candidate_idx]])
                if rf_candidate_zone.geom_type == &#39;Polygon&#39; and (rf_candidate_zone.area / rf_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    rf_selected_zone = rf_candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
                    core_adj_qty.pop(nearest_candidate_idx, None)
                    rf_banned_idx = []
                else:
                    rf_banned_idx.append(nearest_candidate_idx)
            else:
                break

        if not prev_rf_selected_zone:
            zones[&#39;ZONA SALAS REUNION FORMAL 0&#39;] = rf_selected_zone
            rf_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(rf_selected_zone.bounds, objects=True))))
            rf_nearest_idx = [k for k,v in areas.items() if v.bounds in rf_nearest]
        else:
            rf_selected_zones = [prev_rf_selected_zone, rf_selected_zone]
            for i in range(len(rf_selected_zones)):
                zones[&#39;ZONA SALAS REUNION FORMAL &#39; + str(i)] = rf_selected_zones[i]
    
    return rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_ri_zone"><code class="name flex">
<span>def <span class="ident">assign_ri_zone</span></span>(<span>pt_nearest_idx, elements_idx, cat_area, factor, prev_ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, ri_fill)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns informal meeting areas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, prev_ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill):
    &#34;&#34;&#34;Function that assigns informal meeting areas&#34;&#34;&#34;
    if not prev_ri_selected_zone:
        # Se buscan como candidatos, indices de areas disponibles cercanas a la zonas seleccionadas como puestos de trabajo
        if pt_nearest_idx:
            ri_candidate_idx = [k for k,v in areas.items() if k in pt_nearest_idx]
            if not ri_candidate_idx:
                ri_candidate_idx = [k for k,v in areas.items()]
        else:
            ri_candidate_idx = [k for k,v in areas.items()]
        #print(&#34;Candidatos reuniones informales:&#34;, ri_candidate_idx)

        if len(ri_candidate_idx) &gt; 0:
            # En caso que se haya encontrado mas de un candidato que cumpla con algun criterio, se elige el de mayor area
            if len(ri_candidate_idx) &gt; 1:
                ri_candidate_zones = {}
                for c in ri_candidate_idx:
                    ri_candidate_zones[c] = areas[c]
                ri_candidate_zones_areas = {k: v.area for k, v in ri_candidate_zones.items()}
                ri_selected_zone_idx = max(ri_candidate_zones_areas, key=ri_candidate_zones_areas.get)
                ri_selected_zone = ri_candidate_zones[ri_selected_zone_idx]
            elif len(ri_candidate_idx) == 1:
                ri_selected_zone_idx = ri_candidate_idx[0]
                ri_selected_zone = areas[ri_selected_zone_idx]
            
            areas.pop(ri_selected_zone_idx, None)
            shafts_adj_qty.pop(ri_selected_zone_idx, None)
            crystal_adj_qty.pop(ri_selected_zone_idx, None)
            entrances_adj_qty.pop(ri_selected_zone_idx, None)
            core_adj_qty.pop(ri_selected_zone_idx, None)
            ri_banned_idx = []
            if ri_fill:
                expansion_condition = True
            else:
                expansion_condition = ri_selected_zone.area &lt; cat_area[6] + factor*cat_area[6]
            while expansion_condition and len(areas) &gt; 0:
                ri_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(ri_selected_zone.bounds, objects=True))))
                ri_nearest_idx = [k for k,v in areas.items() if v.bounds in ri_nearest and not k in ri_banned_idx]
                nearest_len = {idx: ri_selected_zone.intersection(areas[idx]).length for idx in ri_nearest_idx}
                if nearest_len:
                    nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                    ri_candidate_zone = unary_union([ri_selected_zone, areas[nearest_candidate_idx]])
                    if ri_candidate_zone.geom_type == &#39;Polygon&#39; and (ri_candidate_zone.area / ri_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                        ri_selected_zone = ri_candidate_zone
                        areas.pop(nearest_candidate_idx, None)
                        shafts_adj_qty.pop(nearest_candidate_idx, None)
                        crystal_adj_qty.pop(nearest_candidate_idx, None)
                        entrances_adj_qty.pop(nearest_candidate_idx, None)
                        core_adj_qty.pop(nearest_candidate_idx, None)
                        ri_banned_idx = []
                    else:
                        ri_banned_idx.append(nearest_candidate_idx)
                else:
                    break
            zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] = ri_selected_zone
            ri_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.intersection(ri_selected_zone.bounds, objects=True))))
            ri_nearest_idx = [k for k,v in areas.items() if v.bounds in ri_nearest]
            return ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones
    else:
        ri_zones_list = [prev_ri_selected_zone]
        while len(areas) &gt; 0:
            ri_candidate_idx = [k for k,v in areas.items()]
            for idx in ri_candidate_idx:
                if len(areas) &lt; 1:
                    break
                ri_zones_list.append(areas[idx])
                areas.pop(idx, None)
                shafts_adj_qty.pop(idx, None)
                crystal_adj_qty.pop(idx, None)
                entrances_adj_qty.pop(idx, None)
                core_adj_qty.pop(idx, None)
        ri_zones = unary_union(ri_zones_list)
        if ri_zones.geom_type == &#39;Polygon&#39;:
            zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] = ri_zones
        else:
            ri_zones = list(ri_zones)
            for i in range(len(ri_zones)):
                zones[&#39;ZONA REUNIONES INFORMALES &#39;+ str(i)] = ri_zones[i]
        
        return prev_ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_services_zone"><code class="name flex">
<span>def <span class="ident">assign_services_zone</span></span>(<span>has_shaft, circs_bounds, elements_idx, cat_area, factor, prev_sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns the service zones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, prev_sv_selected_zone, 
                        sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                        entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns the service zones&#34;&#34;&#34;
    if has_shaft:
        sv_candidate_idx = [k for k, v in shafts_adj_qty.items() if v &gt; min(shafts_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not sv_candidate_idx:
            sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
            if not sv_candidate_idx:
                sv_candidate_idx = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
                if not sv_candidate_idx:
                    sv_candidate_idx = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values())]
    else:
        sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values()) and feasible_polygon(cat_dims, areas[k].minimum_rotated_rectangle)]
        if not sv_candidate_idx:
            sv_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; min(core_adj_qty.values())]
        sv_candidate_idx_filter = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and k in sv_candidate_idx]
        if sv_candidate_idx_filter:
            sv_candidate_idx = sv_candidate_idx_filter
    
    #print(&#34;Candidatos zona de servicios:&#34;, sv_candidate_idx)
    sv_candidate_zones = {}
    for c in sv_candidate_idx:
        sv_candidate_zones[c] = areas[c]
    sv_candidate_zones_areas = {k: v.area for k, v in sv_candidate_zones.items()}
    sv_candidate_idx = max(sv_candidate_zones_areas, key=sv_candidate_zones_areas.get)
    
    sv_selected_zone = areas[sv_candidate_idx]
    areas.pop(sv_candidate_idx, None)
    shafts_adj_qty.pop(sv_candidate_idx, None)
    crystal_adj_qty.pop(sv_candidate_idx, None)
    entrances_adj_qty.pop(sv_candidate_idx, None)
    core_adj_qty.pop(sv_candidate_idx, None)
    sv_banned_idx = []
    if prev_sv_selected_zone:
        prev_area = prev_sv_selected_zone.area
    else:
        prev_area = 0
    while sv_selected_zone.area + prev_area &lt; cat_area[4] + factor*cat_area[4] and len(areas) &gt; 0:
        sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zone.bounds, objects=True))))
        sv_nearest_idx = [k for k,v in areas.items() if v.bounds in sv_nearest and not k in sv_banned_idx]
        nearest_len = {idx: sv_selected_zone.intersection(areas[idx]).length for idx in sv_nearest_idx}
        if nearest_len:
            nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
            sv_candidate_zone = unary_union([sv_selected_zone, areas[nearest_candidate_idx]])
            if sv_candidate_zone.geom_type == &#39;Polygon&#39; and (sv_candidate_zone.area / sv_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                sv_selected_zone = sv_candidate_zone
                areas.pop(nearest_candidate_idx, None)
                shafts_adj_qty.pop(nearest_candidate_idx, None)
                crystal_adj_qty.pop(nearest_candidate_idx, None)
                entrances_adj_qty.pop(nearest_candidate_idx, None)
                core_adj_qty.pop(nearest_candidate_idx, None)
                sv_banned_idx = []
            else:
                sv_banned_idx.append(nearest_candidate_idx)
        else:
            break

    if not prev_sv_selected_zone:
        zones[&#39;ZONA SERVICIOS 0&#39;] = sv_selected_zone
        sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zone.bounds, objects=True))))
        sv_nearest_idx = [k for k,v in areas.items() if v.bounds in sv_nearest]
        for circ in circs_bounds:
            if sv_selected_zone.intersects(box(*circ)):
                circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sv_nearest_idx]
                sv_nearest_idx += circ_nearest_idx
    else:
        sv_selected_zones = [prev_sv_selected_zone, sv_selected_zone]
        sv_nearest_idx = []
        for i in range(len(sv_selected_zones)):
            zones[&#39;ZONA SERVICIOS &#39; + str(i)] = sv_selected_zones[i]
            sv_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sv_selected_zones[i].bounds, objects=True))))
            for k,v in areas.items():
                if v.bounds in sv_nearest and not k in sv_nearest_idx:
                    sv_nearest_idx.append(k)
            for circ in circs_bounds:
                if sv_selected_zone.intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sv_nearest_idx]
                    sv_nearest_idx += circ_nearest_idx
    
    return sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.assign_support_zone"><code class="name flex">
<span>def <span class="ident">assign_support_zone</span></span>(<span>core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, prev_sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that assigns support zones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, prev_sp_selected_zone,
                        sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                        entrances_adj_qty, core_adj_qty, zones, cat_dims):
    &#34;&#34;&#34;Function that assigns support zones&#34;&#34;&#34;
    sp_candidate_idx = [k for k, v in entrances_adj_qty.items() if v &gt; 0]
    sp_candidate_filter = [idx for idx in sp_candidate_idx if feasible_polygon(cat_dims, areas[idx])]
    entrances_idx = True
    if not sp_candidate_filter:
        sp_candidate_idx = [k for k, v in core_adj_qty.items() if v &gt; 0 ]
        sp_candidate_filter = [idx for idx in sp_candidate_idx if feasible_polygon(cat_dims, areas[idx])]
        entrances_idx = False

    sp_candidate_idx = sp_candidate_filter
    #print(&#34;Candidatos zona soporte:&#34;, sp_candidate_idx)
    if len(sp_candidate_idx) &gt; 0:
        # Se asume que hay al menos 1 zona candidata
        if len(sp_candidate_idx) &gt; 1:
            sp_candidate_zones = {}
            for c in sp_candidate_idx:
                sp_candidate_zones[c] = areas[c]

            if entrances_idx:
                sp_candidate_zones_areas = {}
                for e in entrances_bounds:
                    ent = box(*e)
                    entrances_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(e, objects=True))))
                    entrances_nearest_idx = [k for k,v in areas.items() if v.bounds in entrances_nearest]
                    for idx in entrances_nearest_idx:
                        inter_lenght = ent.intersection(areas[idx]).length
                        if idx in sp_candidate_zones_areas:
                            sp_candidate_zones_areas[idx] += inter_lenght
                        else:
                            sp_candidate_zones_areas[idx] = inter_lenght
                
                sp_selected_zone_idx = max(sp_candidate_zones_areas, key=sp_candidate_zones_areas.get)
            else:
                core = box(*core_bounds[0])
                core_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(core_bounds[0], objects=True))))
                core_nearest_idx = [k for k,v in areas.items() if v.bounds in core_nearest and k in sp_candidate_idx]
                sp_candidate_zones_areas = {idx: core.intersection(areas[idx]).length for idx in core_nearest_idx}
                sp_selected_zone_idx = max(sp_candidate_zones_areas, key=sp_candidate_zones_areas.get)

            sp_selected_zone = sp_candidate_zones[sp_selected_zone_idx]
        elif len(sp_candidate_idx) == 1:
            sp_selected_zone_idx = sp_candidate_idx[0]
            sp_selected_zone = areas[sp_selected_zone_idx]

        areas.pop(sp_selected_zone_idx, None)
        shafts_adj_qty.pop(sp_selected_zone_idx, None)
        crystal_adj_qty.pop(sp_selected_zone_idx, None)
        entrances_adj_qty.pop(sp_selected_zone_idx, None)
        core_adj_qty.pop(sp_selected_zone_idx, None)
        sp_banned_idx = []
        if prev_sp_selected_zone:
            prev_area = prev_sp_selected_zone.area
        else:
            prev_area = 0
        while sp_selected_zone.area + prev_area &lt; cat_area[5] + factor*cat_area[5] and len(areas) &gt; 0:
            sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zone.bounds, objects=True))))
            sp_nearest_idx = [k for k,v in areas.items() if v.bounds in sp_nearest and not k in sp_banned_idx]
            sp_nearest_idx_filter = [k for k, v in crystal_adj_qty.items() if v == min(crystal_adj_qty.values()) and k in sp_nearest_idx]
            if sp_nearest_idx_filter:
                sp_nearest_idx = sp_nearest_idx_filter
            nearest_len = {idx: sp_selected_zone.intersection(areas[idx]).length for idx in sp_nearest_idx}
            if nearest_len:
                sp_nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                sp_candidate_zone = unary_union([sp_selected_zone, areas[sp_nearest_candidate_idx]])
                if sp_candidate_zone.geom_type == &#39;Polygon&#39;  and (sp_candidate_zone.area / sp_candidate_zone.minimum_rotated_rectangle.area) &gt; .90:
                    sp_selected_zone = sp_candidate_zone
                    areas.pop(sp_nearest_candidate_idx, None)
                    shafts_adj_qty.pop(sp_nearest_candidate_idx, None)
                    crystal_adj_qty.pop(sp_nearest_candidate_idx, None)
                    entrances_adj_qty.pop(sp_nearest_candidate_idx, None)
                    core_adj_qty.pop(sp_nearest_candidate_idx, None)
                    sp_banned_idx = []
                else:
                    sp_banned_idx.append(sp_nearest_candidate_idx)
            else:
                break
        
        if not prev_sp_selected_zone:
            zones[&#39;ZONA SOPORTE 0&#39;] = sp_selected_zone
            sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zone.bounds, objects=True))))
            sp_nearest_idx = [k for k,v in areas.items() if v.bounds in sp_nearest]
            for circ in circs_bounds:
                if sp_selected_zone.intersects(box(*circ)):
                    circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                    circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sp_nearest_idx]
                    sp_nearest_idx += circ_nearest_idx
        else:
            sp_selected_zones = [prev_sp_selected_zone, sp_selected_zone]
            sp_nearest_idx = []
            for i in range(len(sp_selected_zones)):
                zones[&#39;ZONA SOPORTE &#39; + str(i)] = sp_selected_zones[i]
                sp_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(sp_selected_zones[i].bounds, objects=True))))
                for k,v in areas.items():
                    if v.bounds in sp_nearest and not k in sp_nearest_idx:
                        sp_nearest_idx.append(k)
                for circ in circs_bounds:
                    if sp_selected_zones[i].intersects(box(*circ)):
                        circ_nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(circ, objects=True))))
                        circ_nearest_idx = [k for k,v in areas.items() if v.bounds in circ_nearest and not k in sp_nearest_idx]
                        sp_nearest_idx += circ_nearest_idx

    return sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.feasible_polygon"><code class="name flex">
<span>def <span class="ident">feasible_polygon</span></span>(<span>dims, polygon)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that evaluates the feasibility of the polygon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feasible_polygon(dims, polygon):
    &#34;&#34;&#34;Function that evaluates the feasibility of the polygon&#34;&#34;&#34;
    pol_centroid = polygon.centroid
    base_polygon = box(pol_centroid.x - dims[&#39;max_width&#39;] / 2, pol_centroid.y - dims[&#39;max_height&#39;] / 2, pol_centroid.x + dims[&#39;max_width&#39;] / 2, pol_centroid.y + dims[&#39;max_height&#39;] / 2)
    diff_polygon = base_polygon.difference(polygon)
    
    if diff_polygon.area &gt; 0.2*base_polygon.area:
        return False
    
    pol_minx, pol_miny, pol_maxx, pol_maxy = polygon.bounds
    pol_d1 = abs(pol_maxx-pol_minx)
    pol_d2 = abs(pol_maxy-pol_miny)
    pol_max_dim = max(pol_d1, pol_d2)
    pol_min_dim = min(pol_d1, pol_d2)

    base_d1 = dims[&#39;max_width&#39;]
    base_d2 = dims[&#39;max_height&#39;]
    base_max_dim = max(base_d1, base_d2)
    base_min_dim = min(base_d1, base_d2)

    &#39;&#39;&#39;print(&#34;pol_max_dim&#34;, pol_max_dim)
    print(&#34;pol_min_dim&#34;, pol_min_dim)
    print(&#34;base_max_dim&#34;, base_max_dim)
    print(&#34;base_min_dim&#34;, base_min_dim)
    print(&#34;-----&#34;)&#39;&#39;&#39;

    if pol_max_dim &gt;= base_max_dim and pol_min_dim &gt;= base_min_dim:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="SmartLayout.get_category_max_dims"><code class="name flex">
<span>def <span class="ident">get_category_max_dims</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that obtains the modules with the maximum dimensions by category</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_category_max_dims(inlist):
    &#34;&#34;&#34;Function that obtains the modules with the maximum dimensions by category&#34;&#34;&#34;
    cat_max_dims = {}
    for mod in inlist:
        cat_id = mod[4]
        cat_max_dims[cat_id] = {} if cat_id not in cat_max_dims else cat_max_dims[cat_id]
        cat_max_dims[cat_id][&#39;max_width&#39;] = mod[2] if &#39;max_width&#39; not in cat_max_dims[cat_id] else max(mod[2], cat_max_dims[cat_id][&#39;max_width&#39;])
        cat_max_dims[cat_id][&#39;max_height&#39;] = mod[3] if &#39;max_height&#39; not in cat_max_dims[cat_id] else max(mod[3], cat_max_dims[cat_id][&#39;max_height&#39;]) 
        cat_max_dims[cat_id][&#39;max_area&#39;] = cat_max_dims[cat_id][&#39;max_width&#39;]*cat_max_dims[cat_id][&#39;max_height&#39;]
    return cat_max_dims</code></pre>
</details>
</dd>
<dt id="SmartLayout.get_input"><code class="name flex">
<span>def <span class="ident">get_input</span></span>(<span>dictionary)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that read the plant and the selected modules from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input(dictionary):
    &#34;&#34;&#34;Function that read the plant and the selected modules from a dictionary&#34;&#34;&#34;
    Planta = dictionary.get(&#39;selected_floor&#39;).get(&#39;polygons&#39;)
    Workspaces = dictionary.get(&#39;workspaces&#39;)
    plant = []
    for Area in Planta:
        plant.append(
            [Area.get(&#39;name&#39;), [(round(a.get(&#39;x&#39;) / 100, 1), round(a.get(&#39;y&#39;) / 100, 1)) for a in Area.get(&#39;points&#39;)]])

    outline = []
    holes = []
    areas = []
    for p in plant:
        if p[0] == &#39;WYS_AREA_UTIL&#39;:
            outline.append(p)
        elif p[0] == &#39;WYS_HOLE&#39;:
            holes.append(p)
        else:
            areas.append(p)

    input_list = []
    for ws in Workspaces:
        input_list.append([ws.get(&#39;name&#39;), ws.get(&#39;quantity&#39;), ws.get(&#39;width&#39;), ws.get(&#39;height&#39;),
                           ws.get(&#39;subcategory_id&#39;)])

    return outline, holes, areas, input_list</code></pre>
</details>
</dd>
<dt id="SmartLayout.makePos"><code class="name flex">
<span>def <span class="ident">makePos</span></span>(<span>planta, in_list, zones)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that initially positions the modules in the plant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makePos(planta, in_list, zones):
    &#34;&#34;&#34;Function that initially positions the modules in the plant&#34;&#34;&#34;
    make_time = time.time()
    global makeposcnt
    global curr_bx
    in_cnt = 0
    z = []

    mod = Module(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    for j in range(len(in_list)):
        for n in range(in_list[j][1]):
            if in_cnt == makeposcnt:
                mod.name = in_list[j][0]
                mod.qty = in_list[j][1]
                mod.width = round(in_list[j][2], 1)
                mod.height = round(in_list[j][3], 1)
                mod_cat = in_list[j][4]
            in_cnt+=1

    &#39;&#39;&#39;if mod_cat == 1:
        z = [z[0] for z in zones if &#39;ZONA SALAS REUNION FORMAL&#39; in z[1]]
    elif mod_cat == 2:
        z = [z[0] for z in zones if &#39;ZONA PUESTOS DE TRABAJO&#39; in z[1]]
    elif mod_cat == 3:
        z = [z[0] for z in zones if &#39;ZONA TRABAJO PRIVADO&#39; in z[1]]
    elif mod_cat == 4:
        z = [z[0] for z in zones if &#39;ZONA SERVICIOS&#39; in z[1]]
    elif mod_cat == 5:
        z = [z[0] for z in zones if &#39;ZONA SOPORTE&#39; in z[1]]
    elif mod_cat == 6:
        z = [z[0] for z in zones if &#39;ZONA REUNIONES INFORMALES&#39; in z[1]]
    elif mod_cat == 7:
        z = [z[0] for z in zones if &#39;ZONA ESPECIALES&#39; in z[1]]&#39;&#39;&#39;

    zone = None
    zone, zones_qty = select_zone(zones, zone, mod_cat, makeposcnt)
    
    if zone:
        minx, miny, maxx, maxy = zone.bounds
    else:
        minx, miny, maxx, maxy = planta.bounds
    
    #print(round(time.time() - start_time, 2), len(curr_bx), mod.name)
    #print(mod.name)
    rot = False
    larger_than_zone = False
    pos_retries = 0
    zones_idx = makeposcnt
    positional_time_limit = 0.005   # Recomendado 0.08        Tiempos iniciales de posicionamiento de módulos
    overlap_time_limit = 0.005      # Recomendado 0.05        Tiempos iniciales de posicionamiento de módulos
    while True:
        if time.time() - make_time &gt; 3*(positional_time_limit + overlap_time_limit) and not larger_than_zone:
            make_time = time.time()
            zones_idx += 1
            pos_retries += 1
            zone, zones_qty = select_zone(zones, zone, mod_cat, zones_idx)
            minx, miny, maxx, maxy = zone.bounds
        elif larger_than_zone:
            minx, miny, maxx, maxy = planta.bounds

        if rot:
            b = affinity.rotate(b, 90)
        else:
            p = Point(round(randrange(minx, maxx, 20), 1), round(randrange(miny, maxy, 20), 1))
            b = box(p.x - mod.width / 2, p.y - mod.height / 2, p.x + mod.width / 2, p.y + mod.height / 2)

        if pos_retries &lt; zones_qty and zone:
            condition1 = zone.contains(b) and planta.contains(b)
            if time.time() - make_time &gt;= positional_time_limit and not condition1:
                condition1 = zone.intersects(b) and planta.contains(b)
        elif not larger_than_zone:
            larger_than_zone = True
            #print(mod.name)
            condition1 = planta.contains(b)
        else:
            condition1 = planta.contains(b)
        
        if time.time() - make_time &gt;= overlap_time_limit and condition1:
            mod.x, mod.y = p.x, p.y
            curr_bx.append(b)
            makeposcnt += 1
            if makeposcnt &gt;= in_cnt:
                makeposcnt = 0
                curr_bx = []
            return mod

        condition2 = True

        if not curr_bx:
            condition2 = True
        else:
            for bx in curr_bx:
                if b.intersects(bx):
                    condition2 = False

        if condition1 and condition2:
            mod.x, mod.y = p.x, p.y
            curr_bx.append(b)
            makeposcnt += 1
            if makeposcnt &gt;= in_cnt:
                makeposcnt = 0
                curr_bx = []
            return mod
        rot = not rot</code></pre>
</details>
</dd>
<dt id="SmartLayout.make_circ_ring"><code class="name flex">
<span>def <span class="ident">make_circ_ring</span></span>(<span>planta, core, shafts, entrances, voids, ring_width)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates circulations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_circ_ring(planta, core, shafts, entrances, voids, ring_width):
    &#34;&#34;&#34;Function that creates circulations&#34;&#34;&#34;
    p_minx, p_miny, p_maxx, p_maxy = planta.bounds
    c_minx, c_miny, c_maxx, c_maxy = core.bounds
    #e_minx, e_miny, e_maxx, e_maxy = entrances.bounds
    ring_distance_factor = 0.38

    planta_bbox_points = [Point(p_minx, p_miny), Point(p_maxx, p_maxy)]
    core_bbox_points = [Point(c_minx, c_miny), Point(c_maxx, c_maxy)]

    core_bbox_lines = []
    for p in core_bbox_points:
        line_v = LineString([(p.x, p_miny), (p.x, p_maxy)])
        line_h = LineString([(p_minx, p.y), (p_maxx, p.y)])

        core_bbox_lines.append(line_v)
        core_bbox_lines.append(line_h)
    
    planta_bbox_lines = []
    planta_h_bbox_lines = []
    planta_v_bbox_lines = []
    for p in planta_bbox_points:
        line_v = LineString([(p.x, p_miny), (p.x, p_maxy)])
        line_h = LineString([(p_minx, p.y), (p_maxx, p.y)])

        planta_bbox_lines.append(line_v)
        planta_bbox_lines.append(line_h)
        planta_h_bbox_lines.append(line_h)
        planta_v_bbox_lines.append(line_v)

    entrances_bbox_lines = []
    for e in entrances:
        e_minx, e_miny, e_maxx, e_maxy = e.bounds
        entrance_bbox_points = [Point(e_minx, e_miny), Point(e_maxx, e_maxy)]
        dist_minx_maxx = abs(e_maxx - e_minx)
        dist_miny_maxy = abs(e_maxy - e_miny)
        if(dist_minx_maxx &gt; dist_miny_maxy):
            for ep in entrance_bbox_points:
                e_line_v = LineString([(ep.x, p_miny), (ep.x, p_maxy)])
                entrances_bbox_lines.append(e_line_v)
        else:
            for ep in entrance_bbox_points:
                e_line_h = LineString([(p_minx, ep.y), (p_maxx, ep.y)])
                entrances_bbox_lines.append(e_line_h)

    ring_core_candidates = []
    for cb in core_bbox_lines:
        for eb in entrances_bbox_lines:
            if not cb.intersects(eb):
                ring_core_candidates.append(cb)

    if len(shafts) &gt; 0:
        for s in shafts:
            ring_core_candidates = [l for l in ring_core_candidates if not l.intersects(s)]
    if len(ring_core_candidates) &gt; 1:
        line_planta_dists = []
        for lr in ring_core_candidates:
            tmp_dist = []
            for pb in planta_bbox_lines:
                dist = lr.distance(pb)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            line_planta_dists.append(min(tmp_dist))
        #core_inter_len = [l.intersection(core).length for l in ring_core_candidates]
        #max_len_idx = core_inter_len.index(min(core_inter_len))
        min_len_idx = line_planta_dists.index(min(line_planta_dists))
        ring_core_candidates = [ring_core_candidates[min_len_idx]]
    
    
    ring_core_line = ring_core_candidates[0]

    rcl_x_points = []
    rcl_points = list(ring_core_line.coords)
    for p in rcl_points:
        rcl_x_points.append(p[0])
    rcl_diff_x = rcl_x_points[1] - rcl_x_points[0]
    
    if(rcl_diff_x == 0): #vertical
        if(rcl_points[0][0] &gt; core.centroid.x):
            rcl_width = Point(ring_width, 0)
        else:
            rcl_width = Point(-ring_width, 0)
    else: #horizontal
        if(rcl_points[0][1] &gt; core.centroid.y):
            rcl_width = Point(0, ring_width)
        else:
            rcl_width = Point(0, -ring_width)
    rcl_ring_points = []        
    for p in rcl_points:
        rcl_ring_points.append(Point(p[0]+rcl_width.x ,p[1]+rcl_width.y))
    
    rcl_ring_line = LineString(rcl_ring_points)

    ring_core_lines = [ring_core_line, rcl_ring_line]

    ring_lines = list(ring_core_lines)

    core_candidates_lines = [c for c in core_bbox_lines if not ring_core_line.equals(c)]

    #Primera linea espaciada desde el core
    line_planta_dists = []
    core_spaced_lines = []
    for cl in core_candidates_lines:
        cl_x_points =[]
        cl_points = list(cl.coords)
        for p in cl_points:
            cl_x_points.append(p[0])
        cl_diff_x = cl_x_points[1] - cl_x_points[0]
        if(cl_diff_x == 0): #vertical
            tmp_dist = []
            for pl in planta_v_bbox_lines:
                dist = cl.distance(pl)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            min_dist = min(tmp_dist)
            ring_distance = min_dist*ring_distance_factor
            if(cl_points[0][0] &gt; core.centroid.x):
                cl_width = Point(ring_distance, 0)
            else:
                cl_width = Point(-ring_distance, 0)
        else: #horizontal
            tmp_dist = []
            for pl in planta_h_bbox_lines:
                dist = cl.distance(pl)
                if(dist&gt;0):
                    tmp_dist.append(dist)
            min_dist = min(tmp_dist)
            ring_distance = min_dist*ring_distance_factor
            if(cl_points[0][1] &gt; core.centroid.y):
                cl_width = Point(0, ring_distance)
            else:
                cl_width = Point(0, -ring_distance)
        cl_ring_points = []        
        for p in cl_points:
            cl_ring_points.append(Point(p[0]+cl_width.x ,p[1]+cl_width.y))
        core_spaced_lines.append(LineString(cl_ring_points))

    ring_lines += core_spaced_lines

    #Linea de grosor de lineas espaciadas realizadas anteriormente
    core_spaced_width_lines = []
    for cl in core_spaced_lines:
        cl_x_points =[]
        cl_points = list(cl.coords)
        for p in cl_points:
            cl_x_points.append(p[0])
        cl_diff_x = cl_x_points[1] - cl_x_points[0]
        if(cl_diff_x == 0): #vertical
            if(cl_points[0][0] &gt; core.centroid.x):
                cl_width = Point(ring_width, 0)
            else:
                cl_width = Point(-ring_width, 0)
        else: #horizontal
            if(cl_points[0][1] &gt; core.centroid.y):
                cl_width = Point(0, ring_width)
            else:
                cl_width = Point(0, -ring_width)
        cl_ring_points = []        
        for p in cl_points:
            cl_ring_points.append(Point(p[0]+cl_width.x ,p[1]+cl_width.y))
        core_spaced_width_lines.append(LineString(cl_ring_points))

    ring_lines += core_spaced_width_lines
    lu = unary_union(ring_lines + entrances_bbox_lines + [e.exterior for e in entrances] +  list(planta.interiors))
    pols = list(polygonize(planta.intersection(lu)))
    pols = [p for p in pols if p.area &lt; 50]

    entrances_bounds = list(map(lambda x: x.bounds, entrances))
    pols_bounds = list(map(lambda x: x.bounds, pols))

    holes_idx = rtree.index.Index()
    for i, e in enumerate(pols_bounds + entrances_bounds):
        holes_idx.insert(i, e)
    
    #Filtrado de areas que queden dentro del anillo
    for eb in entrances_bounds:
        entrances_circ = [tuple(obj.bbox) for obj in list(holes_idx.nearest(eb, objects=True)) if tuple(obj.bbox) in pols_bounds]
        if len(entrances_circ) &gt; 1:
            entrances_circ_areas = [box(*p).area for p in entrances_circ]
            entrances_circ = [p for p in entrances_circ if box(*p).area == min(entrances_circ_areas)]
        entrances_circ = entrances_circ[0]
        nearest_ec = [tuple(obj.bbox) for obj in list(holes_idx.nearest(entrances_circ, objects=True)) if tuple(obj.bbox) != entrances_circ]
        nearest_ec_areas = [box(*p).area for p in nearest_ec]
        for p in nearest_ec:
            if box(*p).area == max(nearest_ec_areas):
                pols_bounds.remove(p)

    circ_ring_pols = []
    void_pols = [Polygon(v) for v in voids]
    for pol in pols_bounds:
        box_pol = box(*pol)
        is_void = False
        for v in void_pols:
            if box_pol.equals(v):
                is_void = True
                break
        if not is_void:
            circ_ring_pols.append(box_pol)

    return circ_ring_pols</code></pre>
</details>
</dd>
<dt id="SmartLayout.make_zones"><code class="name flex">
<span>def <span class="ident">make_zones</span></span>(<span>planta, shafts, core, circs, entrances, crystal_facs, areas, cat_area, cat_dims)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates the zones where the modules will be located</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_zones(planta, shafts, core, circs, entrances, crystal_facs, areas, cat_area, cat_dims):
    &#34;&#34;&#34;Function that creates the zones where the modules will be located&#34;&#34;&#34;
    zones = {}
    assigned_zones = {}
    p_minx, p_miny, p_maxx, p_maxy = planta.bounds
    c_minx, c_miny, c_maxx, c_maxy = core.bounds
    factor = 0.1
    
    #cat_area = {1:80 ,2:200, 3:70, 4:70, 5:30, 6: 50, 7:20}
    #cat_area = {2:200, 3:40, 4:70, 5:30, 6: 50, 7:20}
    #cat_area = {4:70}
    #cat_area = {1: 68.75, 2: 56.78450000000001, 3: 28.36, 4: 30.6116, 5: 16.790499999999998}
    #cat_area = {1: 80, 2: 160, 3: 58.36, 4: 30.6116, 5: 16.790499999999998, 6: 30, 7:30}
    #cat_area = {1: 36.349999999999994, 2: 56.78450000000001, 3: 38.16, 4: 30.6116, 5: 30, 6:20}
    #cat_area = {1: 36.349999999999994, 2: 113.56900000000002, 3: 28.36, 4: 30.6116, 5: 8.775}

    core_bounds = [core.bounds]
    entrances_bounds = list(map(lambda x: x.bounds, entrances))
    crystal_facs_bounds = list(map(lambda x: x.bounds, crystal_facs))
    circs_bounds = list(map(lambda x: Polygon(x).bounds, circs))
    #areas = {k: a.buffer(0.0001, cap_style=3, join_style=2) for k, a in areas.items()}
    areas_bounds = []
    for key, area in areas.items():
        areas_bounds.append(area.bounds)

    elements_idx = rtree.index.Index()

    crystal_adj_qty = {}
    entrances_adj_qty = {}
    shafts_adj_qty = {}
    core_adj_qty = {}

    if len(shafts) &gt; 0:
        has_shaft = True
    else:
        has_shaft = False

    if has_shaft:
        shafts_bounds = list(map(lambda x: x.bounds, shafts))
        elements = circs_bounds + core_bounds + shafts_bounds + entrances_bounds + crystal_facs_bounds + areas_bounds
        for i, e in enumerate(elements):
            elements_idx.insert(i, e)

        for key, area in areas.items():
            area_nearest = list(elements_idx.nearest(area.bounds, objects=True))
            crystal_adj = [obj for obj in area_nearest if tuple(obj.bbox) in crystal_facs_bounds]
            shafts_adj = [obj for obj in area_nearest if tuple(obj.bbox) in shafts_bounds]
            entrances_adj = [obj for obj in area_nearest if tuple(obj.bbox) in entrances_bounds]
            core_adj = [area.intersection(core).length for obj in area_nearest if tuple(obj.bbox) in core_bounds]
            crystal_adj_qty[key] = len(crystal_adj)
            shafts_adj_qty[key] = len(shafts_adj)
            entrances_adj_qty[key] = len(entrances_adj)
            core_adj_qty[key] = core_adj[0] if core_adj else 0
    else:
        elements = circs_bounds + core_bounds + entrances_bounds + crystal_facs_bounds + areas_bounds
        for i, e in enumerate(elements):
            elements_idx.insert(i, e)

        for key, area in areas.items():
            area_nearest = list(elements_idx.nearest(area.bounds, objects=True))
            crystal_adj = [obj for obj in area_nearest if tuple(obj.bbox) in crystal_facs_bounds]
            entrances_adj = [obj for obj in area_nearest if tuple(obj.bbox) in entrances_bounds]
            core_adj = [area.intersection(core).length for obj in area_nearest if tuple(obj.bbox) in core_bounds]
            crystal_adj_qty[key] = len(crystal_adj)
            entrances_adj_qty[key] = len(entrances_adj)
            core_adj_qty[key] = core_adj[0] if core_adj else 0
    #print(&#34;adyacentes a cristal:&#34;, crystal_adj_qty)
    #print(&#34;adyacentes al core:&#34;, core_adj_qty)
    # Zona de servicios
    # Se selecciona solo 1 area que tenga mas shafts o core cercanos
    sv_selected_zone = None
    sv_nearest_idx = None
    if 4 in cat_area and len(areas) &gt; 0:
        sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, 
                            crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims[4])
        assigned_zones[4] = sv_selected_zone
    
    # Zonas de puestos de trabajo
    pt_selected_zones = None
    pt_nearest_idx = None
    if 2 in cat_area and len(areas) &gt; 0:
        pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_pt_zones(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone,
                    sv_nearest_idx, pt_selected_zones, pt_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[2])
        assigned_zones[2] = pt_selected_zones

    # Zona de soporte
    sp_selected_zone = None
    sp_nearest_idx = None
    if 5 in cat_area and len(areas) &gt; 0:
        sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, sp_selected_zone,
                    sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[5])
        assigned_zones[5] = sp_selected_zone

    # Zona de puestos de trabajo privado
    ptp_selected_zone = None
    ptp_nearest_idx = None
    if 3 in cat_area and len(areas) &gt; 0:
        ptp_selected_zone, ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ptp_zone(circs_bounds, sv_selected_zone, sv_nearest_idx, sp_selected_zone, sp_nearest_idx, elements_idx, cat_area, factor, ptp_selected_zone,
                    ptp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[3])
        assigned_zones[3] = ptp_selected_zone

    # Zona reuniones formales
    rf_selected_zone = None
    rf_nearest = None
    rf_nearest_idx = None
    if 1 in cat_area and len(areas) &gt; 0:
        rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                           elements_idx, cat_area, factor, rf_selected_zone, rf_nearest_idx,
                           areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones)
        assigned_zones[1] = rf_selected_zone
    
    esp_selected_zone = None
    esp_nearest = None
    esp_nearest_idx = None
    # Zona especiales
    if 7 in cat_area and len(areas) &gt; 0:
        esp_selected_zone, esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_esp_zone(sp_nearest_idx, elements_idx, cat_area, factor, esp_selected_zone, 
                    esp_nearest, esp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, cat_dims[7])
        assigned_zones[7] = esp_selected_zone

    ri_selected_zone = None
    ri_nearest_idx = None
    # Zona reuniones informales (o puestos de trabajo informal)
    if 6 in cat_area and len(areas) &gt; 0:
        ri_fill = False
        ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill)
        assigned_zones[6] = ri_selected_zone
    ri_fill = True

    if(len(areas) &gt; 0):
        diff_zones_areas = {}
        for k, zone in assigned_zones.items():
            if isinstance(zone, list):
                area_zone = 0
                for z in zone:
                    area_zone += z.area
                diff_area = area_zone - cat_area[k]
            else:
                diff_area = zone.area - cat_area[k]
            if diff_area &lt; 0:
                diff_zones_areas[k] = diff_area
        #print(diff_zones_areas)
        if diff_zones_areas:
            diff_zones_areas = {k: v for k, v in sorted(diff_zones_areas.items(), key=lambda item: item[1])}
            for k,v in diff_zones_areas.items():
                if k == 1:
                    rf_selected_zone, rf_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                            assign_rf_zone(sv_nearest_idx, sp_nearest_idx, ptp_selected_zone, ptp_nearest_idx,
                                        elements_idx, cat_area, factor, rf_selected_zone, rf_nearest_idx,
                                        areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones)
                    assigned_zones[k] = rf_selected_zone
                if k == 4:
                    sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                            assign_services_zone(has_shaft, circs_bounds, elements_idx, cat_area, factor, sv_selected_zone, sv_nearest_idx, areas, shafts_adj_qty, 
                            crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones, cat_dims[4])
                    assigned_zones[k] = sv_selected_zone
                if k == 5:
                    sp_selected_zone, sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
                        assign_support_zone(core_bounds, entrances_bounds, circs_bounds, elements_idx, cat_area, factor, sp_selected_zone,
                            sp_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                            entrances_adj_qty, core_adj_qty, zones, cat_dims[5])
                    assigned_zones[k] = sp_selected_zone

    last_areas_len = len(areas)
    while len(areas) &gt; 0:
        for zone_name, zone in zones.items():
            nearest = list(map(lambda x: tuple(x.bbox), list(elements_idx.nearest(zone.bounds, objects=True))))
            nearest_idx = [k for k,v in areas.items() if v.bounds in nearest]
            nearest_len = {idx: zone.intersection(areas[idx]).length for idx in nearest_idx if zone.intersection(areas[idx]).geom_type == &#39;LineString&#39; or zone.intersection(areas[idx]).geom_type == &#39;MultiLineString&#39;}
            if nearest_len:
                nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                candidate_zone = unary_union([zone, areas[nearest_candidate_idx]])
                if candidate_zone.geom_type == &#39;Polygon&#39;:
                    zones[zone_name] = candidate_zone
                    areas.pop(nearest_candidate_idx, None)
                    shafts_adj_qty.pop(nearest_candidate_idx, None)
                    crystal_adj_qty.pop(nearest_candidate_idx, None)
                    entrances_adj_qty.pop(nearest_candidate_idx, None)
            elif len(areas) &lt; 1:
                break

        if last_areas_len == len(areas):
            break
        else:
            last_areas_len = len(areas)

    while len(areas) &gt; 0:
        ri_selected_zone = zones[&#39;ZONA REUNIONES INFORMALES 0&#39;] if &#39;ZONA REUNIONES INFORMALES 0&#39; in zones.keys() else None
        ri_selected_zone, ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, entrances_adj_qty, core_adj_qty, zones = \
            assign_ri_zone(pt_nearest_idx, elements_idx, cat_area, factor, ri_selected_zone, 
                    ri_nearest_idx, areas, shafts_adj_qty, crystal_adj_qty, 
                    entrances_adj_qty, core_adj_qty, zones, ri_fill)
                    
    return zones</code></pre>
</details>
</dd>
<dt id="SmartLayout.merge_min_areas"><code class="name flex">
<span>def <span class="ident">merge_min_areas</span></span>(<span>areas, max_dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that joins areas to achieve a minimum area (in m2) for each area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_min_areas(areas, max_dim):
    &#34;&#34;&#34;Function that joins areas to achieve a minimum area (in m2) for each area&#34;&#34;&#34;
    while not all([a.area &gt; max_dim for a in areas.values()]):
        areas_idx = rtree.index.Index()
        for i, e in enumerate([a.bounds for a in areas.values()]):
            areas_idx.insert(i, e)

        new_areas_list = []
        merged_idx = []
        
        for i, a in areas.items():
            if not i in merged_idx:
                if a.area &lt; max_dim:
                    nearest_idx = list(areas_idx.nearest(a.bounds))
                    nearest_len = {idx: a.intersection(areas[idx]).length for idx in nearest_idx if idx != i}
                    nearest_candidate_idx = max(nearest_len, key=nearest_len.get)
                    merged_idx.append(i)
                    merged_idx.append(nearest_candidate_idx)
                    new_area = unary_union([a, areas[nearest_candidate_idx]])
                    new_areas_list.append(new_area)

        leftover_areas = [v for k,v in areas.items() if not k in merged_idx]
        new_areas = {}
        for i, a in enumerate(leftover_areas + new_areas_list):
            new_areas[i] = a
        areas = new_areas

    while not all([all([a1.intersection(a2).area == 0 for a2 in areas.values() if a1 != a2]) for a1 in areas.values()]):
        areas_idx = rtree.index.Index()
        for i, e in enumerate([a.bounds for a in areas.values()]):
            areas_idx.insert(i, e)
        new_areas_list = []
        merged_idx = []

        for i, a in areas.items():
            if not i in merged_idx:
                nearest_idx = [idx for idx in list(areas_idx.nearest(a.bounds)) if idx != i and not idx in merged_idx]
                for idx in nearest_idx:
                    if a.intersection(areas[idx]).area &gt; 0:
                        merged_idx.append(i)
                        merged_idx.append(idx)
                        new_area = unary_union([a, areas[idx]])
                        new_areas_list.append(new_area)
                        break

        leftover_areas = [v for k,v in areas.items() if not k in merged_idx]
        new_areas = {}
        for i, a in enumerate(leftover_areas + new_areas_list):
            new_areas[i] = a
        areas = new_areas

    while not all([a.geom_type == &#39;Polygon&#39; for a in areas.values()]):
        k = 0
        i = 0
        while k + i != len(areas):
            v = areas[k]
            if v.geom_type == &#39;MultiPolygon&#39;:
                new_areas = list(v)
                areas[k] = new_areas.pop(0)
                for na in new_areas:
                    areas[len(areas)] = na
                    i += 1
            k += 1

    return areas</code></pre>
</details>
</dd>
<dt id="SmartLayout.merge_voids"><code class="name flex">
<span>def <span class="ident">merge_voids</span></span>(<span>voids, circ_pols)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that joins circulations and holes in a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_voids(voids, circ_pols):
    &#34;&#34;&#34;Function that joins circulations and holes in a list&#34;&#34;&#34;
    voids_pols = [Polygon(v) for v in voids]
    circ_voids_pols = list(unary_union(voids_pols + circ_pols))

    return [list(circ.exterior.coords) for circ in circ_voids_pols]</code></pre>
</details>
</dd>
<dt id="SmartLayout.min_dist_to_area"><code class="name flex">
<span>def <span class="ident">min_dist_to_area</span></span>(<span>lista)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that calculates the minimum distance of a module to a certain area</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_dist_to_area(lista):
    &#34;&#34;&#34;Function that calculates the minimum distance of a module to a certain area&#34;&#34;&#34;
    my_output = []
    i = 0
    curr_min = lista[0]
    if len(lista) == 1:
        my_output.append(curr_min)
        return (my_output)

    for j in range(i + 1, len(lista)):
        B = lista[j]
        # print(i, j, curr_min, B)
        if curr_min[0] == B[0]:
            if B[1] &lt;= curr_min[1]:
                curr_min = B
            if j + 1 == len(lista):
                my_output.append(curr_min)
                # print(&#39;append&#39;, curr_min)
        else:
            my_output.append(curr_min)
            # print(&#39;append&#39;, curr_min)
            curr_min = B
            if j + 1 == len(lista):
                my_output.append(curr_min)
        i = j
    return my_output</code></pre>
</details>
</dd>
<dt id="SmartLayout.select_zone"><code class="name flex">
<span>def <span class="ident">select_zone</span></span>(<span>zones, zone, mod_cat, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that selects a zone for each module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_zone(zones, zone, mod_cat, n):
    &#34;&#34;&#34;Function that selects a zone for each module&#34;&#34;&#34;
    z_names_qty = 0
    if mod_cat == 1:
        z_names = [k for k,v in zones.items() if &#39;ZONA SALAS REUNION FORMAL&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SALAS REUNION FORMAL &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SALAS REUNION FORMAL 0&#39;]
    elif mod_cat == 2:
        z_names = [k for k,v in zones.items() if &#39;ZONA PUESTOS DE TRABAJO&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA PUESTOS DE TRABAJO &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA PUESTOS DE TRABAJO 0&#39;]
    elif mod_cat == 3:
        z_names = [k for k,v in zones.items() if &#39;ZONA TRABAJO PRIVADO&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA TRABAJO PRIVADO &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA TRABAJO PRIVADO 0&#39;]
    elif mod_cat == 4:
        z_names = [k for k,v in zones.items() if &#39;ZONA SERVICIOS&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SERVICIOS &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SERVICIOS 0&#39;]
    elif mod_cat == 5:
        z_names = [k for k,v in zones.items() if &#39;ZONA SOPORTE&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA SOPORTE &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA SOPORTE 0&#39;]
    elif mod_cat == 6:
        z_names = [k for k,v in zones.items() if &#39;ZONA REUNIONES INFORMALES&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA REUNIONES INFORMALES &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA REUNIONES INFORMALES 0&#39;]
    elif mod_cat == 7:
        z_names = [k for k,v in zones.items() if &#39;ZONA ESPECIALES&#39; in k]
        z_names_qty = len(z_names)
        if z_names_qty &gt; 1:
            zone = zones[&#39;ZONA ESPECIALES &#39; + str(n%(z_names_qty))]
        elif z_names_qty == 1:
            zone = zones[&#39;ZONA ESPECIALES 0&#39;]

    return zone, z_names_qty</code></pre>
</details>
</dd>
<dt id="SmartLayout.smart_layout_async"><code class="name flex">
<span>def <span class="ident">smart_layout_async</span></span>(<span>dictionary, POP_SIZE=50, GENERATIONS=50)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smart_layout_async(dictionary, POP_SIZE=50, GENERATIONS=50):
    result = Smart_Layout(dictionary, POP_SIZE, GENERATIONS, IS_ASYNC=True)
    return result, dictionary</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SmartLayout.Floor"><code class="flex name class">
<span>class <span class="ident">Floor</span></span>
<span>(</span><span>outline_points, holes_list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Floor:
    def __init__(self, outline_points, holes_list):
        self.outline = outline_points
        self.holes = holes_list</code></pre>
</details>
</dd>
<dt id="SmartLayout.Module"><code class="flex name class">
<span>class <span class="ident">Module</span></span>
<span>(</span><span>x, y, rotation, name, identificator, width_value, height_value, qty, fitval1, fitval2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Module:
    def __init__(self, x, y, rotation, name, identificator, width_value, height_value, qty, fitval1, fitval2):
        self.x = x
        self.y = y
        self.rot = rotation
        self.name = name
        self.id = identificator
        self.width = width_value
        self.height = height_value
        self.qty = qty
        self.fitval1 = fitval1
        self.fitval2 = fitval2

    def show(self):
        print(self.name, self.x, self.y, self.rot, self.id, self.width, self.height, self.qty)

    def get_box(self):
        return box(self.x - self.width / 2, self.y - self.height / 2, self.x + self.width / 2, self.y + self.height / 2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="SmartLayout.Module.get_box"><code class="name flex">
<span>def <span class="ident">get_box</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_box(self):
    return box(self.x - self.width / 2, self.y - self.height / 2, self.x + self.width / 2, self.y + self.height / 2)</code></pre>
</details>
</dd>
<dt id="SmartLayout.Module.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self):
    print(self.name, self.x, self.y, self.rot, self.id, self.width, self.height, self.qty)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SmartLayout.Smart_Layout" href="#SmartLayout.Smart_Layout">Smart_Layout</a></code></li>
<li><code><a title="SmartLayout.assign_esp_zone" href="#SmartLayout.assign_esp_zone">assign_esp_zone</a></code></li>
<li><code><a title="SmartLayout.assign_pt_zones" href="#SmartLayout.assign_pt_zones">assign_pt_zones</a></code></li>
<li><code><a title="SmartLayout.assign_ptp_zone" href="#SmartLayout.assign_ptp_zone">assign_ptp_zone</a></code></li>
<li><code><a title="SmartLayout.assign_rf_zone" href="#SmartLayout.assign_rf_zone">assign_rf_zone</a></code></li>
<li><code><a title="SmartLayout.assign_ri_zone" href="#SmartLayout.assign_ri_zone">assign_ri_zone</a></code></li>
<li><code><a title="SmartLayout.assign_services_zone" href="#SmartLayout.assign_services_zone">assign_services_zone</a></code></li>
<li><code><a title="SmartLayout.assign_support_zone" href="#SmartLayout.assign_support_zone">assign_support_zone</a></code></li>
<li><code><a title="SmartLayout.feasible_polygon" href="#SmartLayout.feasible_polygon">feasible_polygon</a></code></li>
<li><code><a title="SmartLayout.get_category_max_dims" href="#SmartLayout.get_category_max_dims">get_category_max_dims</a></code></li>
<li><code><a title="SmartLayout.get_input" href="#SmartLayout.get_input">get_input</a></code></li>
<li><code><a title="SmartLayout.makePos" href="#SmartLayout.makePos">makePos</a></code></li>
<li><code><a title="SmartLayout.make_circ_ring" href="#SmartLayout.make_circ_ring">make_circ_ring</a></code></li>
<li><code><a title="SmartLayout.make_zones" href="#SmartLayout.make_zones">make_zones</a></code></li>
<li><code><a title="SmartLayout.merge_min_areas" href="#SmartLayout.merge_min_areas">merge_min_areas</a></code></li>
<li><code><a title="SmartLayout.merge_voids" href="#SmartLayout.merge_voids">merge_voids</a></code></li>
<li><code><a title="SmartLayout.min_dist_to_area" href="#SmartLayout.min_dist_to_area">min_dist_to_area</a></code></li>
<li><code><a title="SmartLayout.select_zone" href="#SmartLayout.select_zone">select_zone</a></code></li>
<li><code><a title="SmartLayout.smart_layout_async" href="#SmartLayout.smart_layout_async">smart_layout_async</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SmartLayout.Floor" href="#SmartLayout.Floor">Floor</a></code></h4>
</li>
<li>
<h4><code><a title="SmartLayout.Module" href="#SmartLayout.Module">Module</a></code></h4>
<ul class="">
<li><code><a title="SmartLayout.Module.get_box" href="#SmartLayout.Module.get_box">get_box</a></code></li>
<li><code><a title="SmartLayout.Module.show" href="#SmartLayout.Module.show">show</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>